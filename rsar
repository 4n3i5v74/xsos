#!/bin/bash
# rsar v0.1.0rc3 last mod 2013/01/22
# Latest version at <http://github.com/ryran/xsos>
# Copyright 2012, 2013 Ryan Sawhill <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#
#-------------------------------------------------------------------------------

# To make it easy to rename the script filename
pzero=rsar

# Get version from line #2
version=$(sed '2q;d' $0)

# Colors
reset='\033[0;0m'
bold='\033[1;1m'
red='\033[1;31m'

HELP_USAGE() {
  printf "
Usage: ${bold}$pzero SARFILE${reset}... [${bold}-t TIME${reset}] [${bold}--12hr${reset}] [${bold}-x PATTERN${reset}] [${bold}SAROPTIONS${reset}] [${bold}-z${reset}] [${bold}-D DISK${reset}] [${bold}-N NIC${reset}]
 SAROPTIONS is any mix of: [${bold}-bBcdHInPqrRSuvwWy${reset}]  ('${bold}sar -h${reset}' for details)
 GNU getopt used for arg-parsing (argument order arbitrary)
"
}

HELP_BASIC() {
  HELP_USAGE
  printf "
${bold}SARFILE${reset} -- need at least 1 plaintext sar data file (optionally-compressed)
  Spaces in SARFILE name or path will break things (complain if you care)
  Supported file extensions for compressed sar files:
    z, gz, gzip, b, b2, bz, bz2, bzip, bzip2, x, xz, lzma

${bold}TIME${reset} is a regular expression for what time period to display
  eg: '^1[2-5]' or ':[23]0:' or '^(0.:40|2.:40)'

${bold}--12hr${reset} allows $pzero to handle input data with times in 12-hour time format,
instead of the default 24-hour (NOTE: this option should be used whenever
the times in input sar data end with AM/PM notation, regardless of whether
a specific time range is being extracted with ${bold}-t${reset})

${bold}SAROPTIONS${reset} is any mix of regular sar data-selection options, ie any of:
  ${bold}-b -B -c -d -H -I -P -n -q -r -R -S -u -v -w -W -y${reset}
  Note that args passed to ${bold}-I${reset} & ${bold}-n${reset} & ${bold}-P${reset} are cumulative and case-insensitive
    Ex: ${bold}-n Dev,eDEV${reset} works, as does ${bold}-n Dev -n eDEV -n icmp${reset}
        ${bold}-P all${reset} works, as does ${bold}-P 0,4,7${reset}, as does ${bold}-P0 -P 4 -P7 -P 9,12${reset}
  See ${bold}sar -h${reset} & ${bold}sar --help${reset} for more explanation of these options
  
${bold}PATTERN${reset} may be used only once and is a regex for what section(s) to select
  eg: 'svctm', 'iowait', 'runq', 'proc|cswch'
  It is recommended to stick to the above SAROPTIONS to avoid collisions

${bold}SAROPTIONS${reset} and ${bold}-x PATTERN${reset} may be used together
If neither are provided, $pzero shows CPU utilization (like sar does)

Simple examples:
  $pzero sar03 -qut ^2
  $pzero -t^09:30 -n edev,sock -I sum sar19.bz2
  $pzero -x iowait -t^15:30 /tmp/sar26.gz /tmp/sar27.xz
  
${bold}STOP READING NOW if you're confused; that ^^ is all you need to know${reset}

Additional optional selectors:

  ${bold}-z${reset}  Disables auto-selection of the lines beginning with 'Average:'
  
  ${bold}-D BLOCKDEV${reset}  Where BLOCKDEV is a regex for which block devices to select
    e.g.: 'dev8-16' or '7.$' or 'sda2|rootlv'
  
  ${bold}-N NETDEV${reset}  Where NETDEV is a regex for which interfaces to select
    e.g.: 'eth0' or 'eth[12]' or 'bond[1-3]'

"
  exit
}

# Help? Version? Update?
case $1 in
  -\?|-h)           HELP_BASIC
;;
  --help|help)      HELP_BASIC
;;
  --vers|--version) echo "Version info: ${version:2}"; exit
;;
  --update)      HELP_USAGE; exit
esac

# If BASH is not v4+, fail
if [[ $BASH_VERSINFO -lt 4 ]]; then
  printf "$pzero: Requires BASH v4.0 or higher (RHEL6/Fedora11 and above)\n\n" >&2
  exit 32
fi
  
  
# GNU getopt option definitions:
saropts='bBcdHI:n:P:qrRSuvwWy'
extraopts='N:D:zt:x:'
shortopts=$saropts$extraopts
longopts='12hr'

# Check for bad switches
getopt -Q --name=$pzero -o $shortopts -l $longopts -- "$@" || { HELP_USAGE; exit 64; }

# Setup file-input array
declare -A Input


# Check that we have what appears to be a good sar file 
SARFILECHECK() {
  # Does file exist?
  [[ -f $1 ]] || { echo "$pzero: Cannot access '$1': No such file or directory" >&2; return 66; }
  
  # Set local vars
  local err file unzip
  err="$pzero: Unable to read '$1'"
  shopt -qs nocasematch  # Enable case-insensitive comparison
  file=$(file -bL -e encoding -e cdf -e compress -e elf -e tar -e soft $1 2>/dev/null)
  
  # Is file readable?
  if [[ ! -r $1 ]]; then
    echo "${err}: Permission denied" >&2
    return 77
  
  # Is file plain-text?
  elif [[ ${file:0:5} == ASCII ]]; then
    # Set cat as the handler for the file
    Input[$1]=cat
  
  # So file is binary data, but is it compressed?
  else
    # Check file extension for standard extension indicating compression
    case ${1##*.} in
      z|gz|gzip)          unzip=zcat
        ;;
      bz|bz2|bzip|bzip2)  unzip=bzcat
        ;;
      lzma|x|xz)          unzip=xzcat
        ;;
      # No extension we can deal with; game over man
      *)  echo -e "${err}: Not a plain-text (optionally-compressed) sar file" >&2
          return 65
    esac
    # Set the appropriate unzip cmd as the handler for file
    Input[$1]=$unzip
  fi
  shopt -qu nocasematch  # Disable case-insensitive comparison
}


__CHECK_ARGS_I() {
  shopt -qs nocasematch  # Enable case-insensitive comparison
  case "$1" in
    SUM)
        ;;
    *)
        echo "$pzero: Invalid argument to option: '-I'" >&2
        echo "Hint: Use BASH tab-completion after typing '-I'" >&2
        echo "Currently-valid args are: SUM" >&2
        exit 64
  esac
  shopt -qu nocasematch  # Disable case-insensitive comparison
}


__CHECK_ARGS_n() {
  shopt -qs nocasematch  # Enable case-insensitive comparison
  local k
  for k in $(sed 's/,/ /g' <<<"$1"); do
    case $k in
      DEV|EDEV|NFS|NFSD|SOCK|IP|EIP|ICMP|EICMP|TCP|ETCP|UDP|SOCK6|IP6|EIP6|ICMP6|EICMP6|UDP6)
          ;;
      *)
          echo "$pzero: Invalid argument to option: '-n'" >&2
          echo "Use BASH tab-completion after '-n' to see most common choices" >&2
          echo -e "See ${bold}sar -h${reset} for full list" >&2
          exit 64
    esac
  done
  shopt -qu nocasematch  # Disable case-insensitive comparison
}


__CHECK_ARGS_P() {
  shopt -qs nocasematch  # Enable case-insensitive comparison
  local p
  for p in $(sed 's/,/ /g' <<<"$1"); do
    [[ $p == ALL || $p =~ ^[0-9]+$ ]] || {
        echo "$pzero: Invalid argument to option: '-P'" >&2
        echo -e "See ${bold}sar --help${reset} for usage" >&2
        exit 64
    }
  done
  shopt -qu nocasematch  # Disable case-insensitive comparison
}

    
__SPLIT_ARGS() {
  shopt -qs nocasematch  # Enable case-insensitive comparison
  if [[ $1 == cpu ]]; then
    # If handling cpu args strip leading/trailing commas & replace commas with regex pipe 
    sed -re "s/(^,*|,*$)//g" -e "s/,/|/g" <<<"${2^^}"
  else
    # Otherwise, strip leading/trailing commas & replace commas with spaces
    sed -re "s/(^,*|,*$)//g" -e "s/^/$1/" -e "s/,/ $1/g" <<<"${2^^}"
  fi
  shopt -qu nocasematch  # Disable case-insensitive comparison
}


# Parse command-line arguments
PARSE() {
  # Local vars
  local file errs
  
  # Run through all of our arguments
  until [[ $1 = -- ]]; do
    case "$1" in
      # Standard sar selection options
      -b)   Selection="$Selection iotransf" ; shift ;;
      -B)   Selection="$Selection paging"   ; shift ;;
      -c)   Selection="$Selection process"  ; shift ;;
      -d)   Selection="$Selection blockdev" ; shift ;;
      -H)   Selection="$Selection hugepage" ; shift ;;
      -q)   Selection="$Selection queue"    ; shift ;;
      -r)   Selection="$Selection memutil"  ; shift ;;
      -R)   Selection="$Selection mempages" ; shift ;;
      -S)   Selection="$Selection memswap"  ; shift ;;
      -u)   Selection="$Selection cpuutil"  ; shift ;;
      -v)   Selection="$Selection kerntbls" ; shift ;;
      -w)   Selection="$Selection cswitch"  ; shift ;;
      -W)   Selection="$Selection swapping" ; shift ;;
      -y)   Selection="$Selection tty"      ; shift ;;
      # Interrupt selection options
      -I)   __CHECK_ARGS_I "$2" &&
            Selection="$Selection $(__SPLIT_ARGS int $2)" ; shift 2 ;;
      # Net selection options
      -n)   __CHECK_ARGS_n "$2"
            Selection="$Selection $(__SPLIT_ARGS net $2)" ; shift 2 ;;
      # Processor selection options
      -P)   __CHECK_ARGS_P "$2"
            Cpus="$Cpus|$(__SPLIT_ARGS cpu $2)" ; shift 2 ;;
      # Other options 
      -t)       Time=$2         ; shift 2 ;;
      -x)       DirectSrch=$2   ; shift 2 ;;
      -D)       BlockDevs=$2    ; shift 2 ;;
      -N)       NetDevs=$2      ; shift 2 ;;
      -z)       AverageSrch=    ; shift ;;
      --12hr)   TimeFmt=12hr    ; shift ;;
    esac
  done
  shift  # (to get rid of the '--')
  
  # Quit with err & usage if no file given
  [[ -z $1 ]] && { echo "$pzero: Need at least 1 plain-text sar file (optionally-compressed) to continue" >&2; HELP_USAGE; exit 1; }
  
  # Check each file; if bad, print err; if good, add to our input array
  for file in $@; do
    SARFILECHECK $file || errs=1
  done
  
  # If files were given, but none of them were good, exit now
  [[ -z ${Input[@]} ]] && { HELP_USAGE; exit 1; }
  
  # If we had some file errs, but can continue, add extra space to stderr
  [[ -n $errs ]] && echo >&2
}


# 'Average:'-line selection: show by default
# Note that this really SHOULD be here, before we call the parser
[[ -z $AverageSrch ]] && AverageSrch='|Average'

# Call the parser
PARSE $(getopt -u --name=$pzero -o $shortopts -l $longopts -- "$@")

# Time format selection: expect 24-hour time by default
[[ -z $TimeFmt ]] && TimeFmt='24hr'

# Time-period selection: show all by default
[[ -z $Time ]] && Time='.'

# Block device selection: show all by default
[[ -z $BlockDevs ]] && BlockDevs='.'

# Network interface selection: show all by default
[[ -z $NetDevs ]] && NetDevs='.'

# CPU selection: by default show only combined cpu util ('all' in field 2)
if [[ -z $Cpus ]]; then
  Cpus='all'
elif [[ Cpus =~ ALL ]]; then
  # If user passed '-P ALL' then let's match everything
  Cpus='.'
fi


# Our universal search function
search() {
  local header drilldown file
  header=$1
  drilldown='.'

  # If we're dealing with CPU utilization, need some special handling
  if [[ $header =~ CPU|usr|user|nice|sys|iowait|(^|%)steal|irq|soft|guest|idle ]]; then
    drilldown="^($Cpus)$"

  # Same for network statistics
  elif [[ $header =~ IFACE|rx|tx|byt|drop|rxbyt|txbyt|rxpck|txpck|rxkB|txkB|rxcmp|txcmp|rxmcst|rxerr|txerr|coll|rxdrop|txdrop|txcarr|rxfram|rxfifo|txfifo ]]; then
    drilldown=$NetDevs
  
  # Same for disk activity
  elif [[ $header =~ DEV|rd_sec|wr_sec|avgrq-sz|avgqu-sz|await|svctm|util ]]; then
    drilldown=$BlockDevs
  fi
  
  for file in ${!Input[@]}; do
    [[ ${#Input[@]} -gt 1 ]] &&
      printf "${bold}------------------------ $file ------------------------${reset}\n"
    if [[ $TimeFmt == 24hr ]]; then
      # If we're expecting input to be in 24hr time, then fields:
      # $1 is time, $2 is name of cpu|netdev|blockdev
      ${Input[$file]} $file | awk "BEGIN{RS=\"\n\n\"} /$header/" |
        awk "/$header/ || (\$1 ~ /$Time$AverageSrch/ && \$2 ~ /$drilldown/)"
    else
      # If we're expecting input to be in 12hr time, then fields:
      # $1 and $2 are time (e.g. 12:50:01 AM), $3 is name of cpu|netdev|blockdev
      # But not for the "Average:" lines -- which are the same as with 24hr time
      ${Input[$file]} $file | awk "BEGIN{RS=\"\n\n\"} /$header/" | 
        awk "/$header/ || (\$1\$2 ~ /$Time/ && \$3 ~ /$drilldown/) || (\$1 ~ /${AverageSrch//|/}/ && \$2 ~ /$drilldown/)"
    fi
    echo
  done
}


if [[ -n $DirectSrch ]]; then
  # If a direct regex search was provided, do it
  search "$DirectSrch"
  
elif [[ -z $Selection ]]; then
  # Otherwise, default to cpu utilization like sar
  Selection=cpuutil
fi

# If some sar options were used, time to get to work
for module in $Selection; do case $module in
  iotransf)   search bread        ;;
  paging)     search pgpgin       ;;
  process)    search proc         ;;
  blockdev)   search await        ;;
  hugepage)   search hugfree      ;;
  queue)      search runq         ;;
  memutil)    search memfree      ;;
  mempages)   search frmpg        ;;
  memswap)    search swpfree      ;;
  cpuutil)    search iowait       ;;
  kerntbls)   search dentunusd    ;;
  cswitch)    search cswch        ;;
  swapping)   search pswpin       ;;
  tty)        search rcvin        ;;
  intSUM)     search "INTR.*sum"      ;;
  netDEV)     search "IFACE.*rxpck"   ;;
  netEDEV)    search "IFACE.*rxerr"   ;;
  netNFS)     search " call.*retrans" ;;
  netNFSD)    search "scall"          ;;
  netSOCK)    search "totsck"         ;;
  netIP)      search "totsck"         ;;
  netEIP)     search "totsck"         ;;
  netICMP)    search "oadrmkr"        ;;
  netEICMP)   search "oerr"           ;;
  netTCP)     search "oseg"           ;;
  netETCP)    search "atmptf"         ;;
  netUDP)     search "idgmerr"        ;;
  netSOCK6)   search "tcp6sck"        ;;  
  netIP6)     search "irec6"          ;;
  netEIP6)    search "ihdrer6"        ;;
  netICMP6)   search "imsg6"          ;;
  netEICMP6)  search "ierr6"          ;;
  netUDP6)    search "idgm6"          ;;
esac; done
  
