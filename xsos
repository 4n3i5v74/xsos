#!/bin/bash
# xsos v0.0.9rc7b last mod 2012/12/03
# Latest version at <http://github.com/ryran/xsos>
# Copyright 2012 Ryan Sawhill <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------

# So much still to do ... Suggestions always welcome though.

# To make it easy to rename the script filename
pzero=${0##*/}

# Get version from line #2
version=$(sed '2q;d' $0)

# Colors and colors and colors oh my (but only for bash v4)
if [[ $BASH_VERSINFO -ge 4 ]]; then
  declare -A c
  c[reset]='\033[0;0m'
  c[grey]='\033[00;30m';  c[GREY]='\033[01;30m';  c[bg_GREY]='\033[40m'
  c[red]='\033[0;31m';    c[RED]='\033[1;31m';    c[bg_RED]='\033[41m'
  c[green]='\033[0;32m';  c[GREEN]='\033[1;32m';  c[bg_GREEN]='\033[42m'
  c[orange]='\033[0;33m'; c[ORANGE]='\033[1;33m'; c[bg_ORANGE]='\033[43m'
  c[blue]='\033[0;34m';   c[BLUE]='\033[1;34m';   c[bg_BLUE]='\033[44m'
  c[purple]='\033[0;35m'; c[PURPLE]='\033[1;35m'; c[bg_PURPLE]='\033[45m'
  c[cyan]='\033[0;36m';   c[CYAN]='\033[1;36m';   c[bg_CYAN]='\033[46m'
fi

# ==============================================================================
# ENVIRONMENT VARIABLES -- Modify these by setting them in your shell
# environment, e.g. ~/.bash_profile or /etc/profile.d/xsos.sh
#
# COLORS
#
#   XSOS_COLORS (bool: y/n)
#     Controls whether color is enabled or disabled by default
#     Can also be controlled by cmdline arg 
      [[ -z $XSOS_COLORS ]] && XSOS_COLORS=y
#
#   XSOS_COLOR_RESET -- color to reset terminal to after using other colors
      [[ -z $XSOS_COLOR_RESET ]] && XSOS_COLOR_RESET=${c[reset]}
#
#   XSOS_COLOR_H1 -- color for content modules' primary header
      [[ -z $XSOS_COLOR_H1 ]] && XSOS_COLOR_H1=${c[RED]}
#
#   XSOS_COLOR_H2 -- color for content modules' secondary header
      [[ -z $XSOS_COLOR_H2 ]] && XSOS_COLOR_H2=${c[PURPLE]}
#
#   XSOS_COLOR_H3 -- color for content modules' tertiary header
      [[ -z $XSOS_COLOR_H3 ]] && XSOS_COLOR_H3=${c[blue]}
#
#   XSOS_COLOR_IMPORTANT -- color for drawing attention to important data
      [[ -z $XSOS_COLOR_IMPORTANT ]] && XSOS_COLOR_IMPORTANT=${c[cyan]}
#
#   XSOS_COLOR_WARN1 -- color for level-1 warnings
      [[ -z $XSOS_COLOR_WARN1 ]] && XSOS_COLOR_WARN1=${c[orange]}
#
#   XSOS_COLOR_WARN2 -- color for level-2 warnings
      [[ -z $XSOS_COLOR_WARN2 ]] && XSOS_COLOR_WARN2=${c[ORANGE]}
#
#   XSOS_COLOR_IFUP -- color for ethtool InterFace "up"
      [[ -z $XSOS_COLOR_IFUP ]] && XSOS_COLOR_IFUP=${c[green]}
#
#   XSOS_COLOR_IFDOWN -- color for ethtool InterFace "down"
      [[ -z $XSOS_COLOR_IFDOWN ]] && XSOS_COLOR_IFDOWN=${c[orange]}
#
#
# XSOS_FOLD_WIDTH (positive int)
#   Some content modules print line of unpredictable length
#   This setting controls the wrapping width for commands that use it
#   Changing to 0 causes width of terminal to be used
    [[ -z $XSOS_FOLD_WIDTH ]] && XSOS_FOLD_WIDTH=76
#
#
# XSOS_UPDATE_CONFIRM (bool: y/n)
#   Controls whether built-in update function prompts for confirmation
    [[ -z $XSOS_UPDATE_CONFIRM ]] && XSOS_UPDATE_CONFIRM=y
#
#
# XSOS_HEADING_SEPARATOR (str)
#   Acts as a separator between content modules
#   Should include at least 1 trailing new-line
    [[ -z $XSOS_HEADING_SEPARATOR ]] && XSOS_HEADING_SEPARATOR="\n"
#
#
# XSOS_ALL_VIEW (str of variables, semicolon-separated)
#   Controls what content modules to run when -a/--all switch is used
    [[ -z $XSOS_ALL_VIEW ]] && XSOS_ALL_VIEW='bios=y; os=y; cpu=y; mem=y; disks=y; lspci=y; ethtool=y; ip=y; net=y; sysctl=y; ps=y'
#
#
# XSOS_DEFAULT_VIEW (str of variables, semicolon-separated)
#   Controls default content modules, i.e. what to run when none are specififed
    [[ -z $XSOS_DEFAULT_VIEW ]] && XSOS_DEFAULT_VIEW='os=y; cpu=y; mem=y; lspci=y; ip=y'
#
#
# XSOS_PS_LEVEL (int: 0-3)
#   Controls verbosity level (3 being highest) in PSCHECK() function
    [[ -z $XSOS_PS_LEVEL ]] && XSOS_PS_LEVEL=1
#
#
# XSOS_MEM_UNIT (str: k, m, g)
#   Sets unit used by MEMINFO() function for printing
#   Can also be controlled by cmdline opts -K/-M/-G
    [[ -z $XSOS_MEM_UNIT ]] && XSOS_MEM_UNIT="g"
#
#
# XSOS_NET_UNIT (str: b, k, m, g, t)
#   Sets unit used by PROC_NET() function for printing Rx & Tx Bytes
#   Can also be controlled by cmdline opts -K/-M/-G
    [[ -z $XSOS_NET_UNIT ]] && XSOS_NET_UNIT="m"
#
#
# ==============================================================================


# Variables used a few times for indentation
# Many more times the spaces are just manually inserted; not ready to be env variables
H2INDENT="    "
H3INDENT="      "


VERSINFO() {
  echo "Version info: ${version:2}
See <github.com/ryran/xsos> to report bugs or suggestions"
  exit
}

HELP_USAGE() {
  echo "Usage: $pzero [-xKMG] [-w N] [-v N] [-abocmdleinsp] [SOSREPORT-ROOT]"
  echo "  or:  $pzero [--B|--C|--M|--D|--L|--I|--N|--P FILE]..."
  echo "  or:  $pzero [-?|-h|--help]"
  echo "  or:  $pzero [-U|--update]"
  echo "Extract useful data about system from SOSREPORT-ROOT or else localhost"
}

HELP_OPTS_CONTENT() {
  echo "
Content options:"
  echo "
 -a, --all@show everything
 -b, --bios@show info from dmidecode
 -o, --os@show release, hostname, uptime, loadavg, cmdline
 -c, --cpu@show info from /proc/cpuinfo
 -m, --mem@show info from /proc/meminfo
 -d, --disks@show info from /proc/partitions + dm-multipath
 -l, --lspci@show info from lspci
 -e, --ethtool@show info from ethtool
 -i, --ip@show info from ip addr (BASH v4+ required)
 -n, --net@show info from /proc/net/dev
 -s, --sysctl@show important kernel sysctls
 -p, --ps@inspect running processes via ps" | column -ts@
}

HELP_OPTS_DISPLAY() {
  echo "
Display options:"
  echo "
 -x, --nocolor@disable output colorization
 -K, --kb@show /proc/meminfo & /proc/net/dev in KiB
 -M, --mb@show /proc/meminfo & /proc/net/dev in MiB
 -G, --gb@show /proc/meminfo & /proc/net/dev in GiB
 -w, --width=N@change fold-width (76-char default; 0 autodetects)
 -v, --verbose=N@specify ps verbosity level (0-4, defaults to 1)" | column -ts@
}

HELP_OPTS_SPECIAL() {
  echo "
Special options (BASH v4+ required):"
  echo "
 --B=FILE@read from FILE containing \`dmidecode\` dump
 --C=FILE@read from FILE containing /proc/cpuinfo dump
 --M=FILE@read from FILE containing /proc/meminfo dump
 --D=FILE@read from FILE containing /proc/partitions dump
 --L=FILE@read from FILE containing \`lspci\` dump
 --I=FILE@read from FILE containing \`ip addr\` dump
 --N=FILE@read from FILE containing /proc/net/dev dump
 --P=FILE@read from FILE containing \`ps aux\` dump" | column -ts@
}

HELP_SHORT() {
  HELP_USAGE
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  HELP_OPTS_SPECIAL
  echo -e "\nRun with '--help' to see full help page\n"
  VERSINFO
}

HELP_EXTENDED() {
  HELP_USAGE
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  echo "
If no content options are specified, $pzero parses the environment variable
XSOS_DEFAULT_VIEW to figure out what information to display. If this variable
is unset at runtime, it is initialized internally as follows:

  XSOS_DEFAULT_VIEW='os=y; cpu=y; mem=y; lspci=y; ip=y'

If desired, follow the pattern to tweak it to your preference.

If SOSREPORT-ROOT isn't provided, the data will be gathered from the localhost;
however, bios, multipath, and ethtool output will only be displayed if running
as root (UID 0). When executing in this manner as non-root, those modules will
be skipped, and a warning printed to stderr.

Sometimes a full sosreport isn't available; sometimes you simply have a
dmidecode-dump or the contents of /proc/meminfo and you'd like a summary..."
  HELP_OPTS_SPECIAL
  echo "
As is hopefully clear, each of these options requires a filename as an
argument. These options can be used together, but cannot be used in concert
with regular 'Content options' -- Content opts are ignored if Special options
are detected. Also note: the '=' can be replaced with a space if desired.

Re BASH v4+:
BASH associative arrays are used for various things. In short, if running $pzero
on earlier BASH versions (e.g. RHEL5), you get ...
 * No output colorization
 * No -i/--ip
 * No parsing of 'Special options'

The following environment variables change the behavior of $pzero:
  XSOS_COLORS    XSOS_FOLD_WIDTH    XSOS_HEADING_SEPARATOR
  XSOS_ALL_VIEW  XSOS_DEFAULT_VIEW  XSOS_UPDATE_CONFIRM
  XSOS_PS_LEVEL  XSOS_MEM_UNIT      XSOS_NET_UNIT
  
The following environment variables control the default colors:
  XSOS_COLOR_RESET      XSOS_COLOR_WARN1  XSOS_COLOR_WARN2
  XSOS_COLOR_IMPORTANT  XSOS_COLOR_IFUP   XSOS_COLOR_IFDOWN
  XSOS_COLOR_H1         XSOS_COLOR_H2     XSOS_COLOR_H3

See the first page or so of $pzero for full details on env variables.
"
  VERSINFO
}


UPDATE() {
  echo -e "${c[blue]}Checking $0 against latest version at github.com/ryran/xsos ...${c[GREY]}\n"
  latest_version_file=$(mktemp --tmpdir xsos_latest.XXXXX) || {
    echo -e "${c[RED]}Unable to create temporary file with mktemp${c[reset]}"
    exit 73
  }
  trap "rm '$latest_version_file'" EXIT

  # Download latest version of xsos with wget or curl
  if command -v wget >/dev/null; then
    wget https://raw.github.com/ryran/xsos/master/xsos -O "$latest_version_file" || {
      ret=$?
      echo -e "${c[RED]}Exiting due to wget error${c[reset]}"
      exit $ret
    }
  elif command -v curl >/dev/null; then
    curl https://raw.github.com/ryran/xsos/master/xsos -o "$latest_version_file" && echo || {
      ret=$?
      echo -e "${c[RED]}Exiting due to curl error${c[reset]}"
      exit $ret
    }
  else
    echo -e "${c[RED]}Need either wget or curl in PATH to download the latest version${c[reset]}"
    exit 72
  fi
  
  # Save version string
  latest_version=$(sed '2q;d' "$latest_version_file")

  # Compare currently running xsos with downloaded file
  if ! diff "$0" "$latest_version_file" >/dev/null; then
    echo -e "${c[blue]}The version you are running reports as:\n\t${c[orange]}${version:2}${c[blue]}\nThe version on github appears to be different and reports as:\n\t${c[ORANGE]}${latest_version:2}${c[blue]}"
    if [[ $XSOS_UPDATE_CONFIRM != n ]]; then
      echo -e "Type ${c[GREEN]}y${c[blue]} to see the differences between them, or else any other key${c[reset]}"
      read -p "> "
      if [[ $REPLY == y ]]; then
        if [[ -n $DISPLAY ]] && command -v meld >/dev/null; then
          meld "$0" "$latest_version_file" 2>/dev/null
        elif [[ -n $DISPLAY ]] && command -v gvimdiff >/dev/null; then
          gvimdiff "$0" "$latest_version_file" 2>/dev/null
        elif command -v vimdiff; then
          vimdiff "$0" "$latest_version_file"
        else
          # set name of tmp diff file
          diff_file=$latest_version_file.patch; trap "rm '$diff_file'" EXIT;
          # create a diff file
          diff -u "$0" "$latest_version_file" > "$diff_file"
          if [[ -n $DISPLAY ]] && command -v gedit >/dev/null; then
            gedit "$diff_file" 2>/dev/null
          else
            less "$diff_file"
          fi
        fi
      fi
    fi
    [[ -w $0 ]] || {
      echo -e "${c[RED]}You do not have write permission to modify '$0'${c[reset]}"
      exit 77
    }
    if [[ $XSOS_UPDATE_CONFIRM != n ]]; then
      echo -e "${c[blue]}Type ${c[GREEN]}u${c[blue]} to replace $0 with the latest version\nOr any other key to cancel${c[reset]}"
      read -p "> "
    else
      REPLY=u
    fi
    if [[ $REPLY == u ]]; then
      echo -e "${c[blue]}Backing up current version and replacing it with downloaded version ...${c[cyan]}"
      cp -v "$0" "$(mktemp --tmpdir xsos-$(awk {print\$3} <<<"$version").XXX)"
      cp -v "$latest_version_file" "$0"
      chmod +x "$0"
      echo -e "${c[reset]}"
    else
      echo -e "${c[cyan]}Not performing update${c[reset]}\n"
    fi
  else
    echo -e "${c[blue]}$0 is the same version as what is on github, i.e.,\n\t${c[BLUE]}${version:2}${c[reset]}\n"
  fi
  exit
}


# Help? Version? Update?
case $1 in
  -\?|-h)           HELP_SHORT
;;
  --help|help)      HELP_EXTENDED
;;
  --vers|--version) echo "Version info: ${version:2}"; exit
;;
  -U|--update)      UPDATE
esac

# GNU getopt short and long options:
sopts='xKMGw:v:abocmdleinsp'
lopts='nocolor,kb,mb,gb,width:,verbose:,all,bios,os,cpu,mem,disks,lspci,ethtool,ip,net,sysctl,ps,B:,C:,M:,D:,L:,I:,N:,P:'

# Check for bad switches
getopt -Q --name=$pzero -o $sopts -l $lopts -- "$@" || { HELP_USAGE; exit 64; }

# Setup assoc array for single-file options
unset sfile
[[ $BASH_VERSINFO -ge 4 ]] && declare -A sfile 

# Checker for cmdline options
_OPT_CHECK() {
  option=$1
  chosen_opt=$2
  check_type=$3
  valid_opts=$4
  if [[ $check_type == range ]]; then
    for n in $(seq $valid_opts); do
      [[ $n == $chosen_opt ]] && return
    done
    echo "$pzero: option '$option' expects number from range ${valid_opts// /-}"
    
  elif [[ $check_type == naturalnumber ]]; then
    grep -qs '^[0-9]*$' <<<"$chosen_opt" && return
    echo "$pzero: option '$option' expects any natural number, including zero"
    
  elif [[ $check_type == str ]]; then
    for s in $valid_opts; do
      [[ $s == $chosen_opt ]] && return
    done
    echo "$pzero: option '$option' expects one of: { $valid_opts } "
  fi
  exit 64
}


# Parse command-line arguments
PARSE() {
  unset opts all bios os cpu mem disks lspci ethtool ip net sysctl ps
  until [[ $1 = -- ]]; do
    case $1 in
      -x|--nocolor) shift; XSOS_COLORS=n ;;
      -K|--kb)      shift; XSOS_MEM_UNIT="k"; XSOS_NET_UNIT="k" ;;
      -M|--mb)      shift; XSOS_MEM_UNIT="m"; XSOS_NET_UNIT="m" ;;
      -G|--gb)      shift; XSOS_MEM_UNIT="g"; XSOS_NET_UNIT="g" ;;
      -w|--width)   _OPT_CHECK "width" "$2" naturalnumber
                      [[ $2 == 0 ]] && XSOS_FOLD_WIDTH=$(($(tput cols)-3)) || XSOS_FOLD_WIDTH=$2
                      shift 2 ;;
      -v|--verbose) _OPT_CHECK "verbose" "$2" range "0 4"
                      XSOS_PS_LEVEL=$2
                      shift 2 ;;
      -a|--all)     shift; opts=y; all=y     ;;
      -b|--bios)    shift; opts=y; bios=y    ;;
      -o|--os)      shift; opts=y; os=y      ;;
      -c|--cpu)     shift; opts=y; cpu=y     ;;
      -m|--mem)     shift; opts=y; mem=y     ;;
      -d|--disks)   shift; opts=y; disks=y   ;;
      -l|--lspci)   shift; opts=y; lspci=y   ;;
      -e|--ethtool) shift; opts=y; ethtool=y ;;
      -i|--ip)      shift; opts=y; ip=y      ;;
      -n|--net)     shift; opts=y; net=y     ;;
      -s|--sysctl)  shift; opts=y; sysctl=y  ;;
      -p|--ps)      shift; opts=y; ps=y      ;;
      --B)  sfile[B]=$2; shift 2 ;;
      --C)  sfile[C]=$2; shift 2 ;;
      --M)  sfile[M]=$2; shift 2 ;;
      --D)  sfile[D]=$2; shift 2 ;;
      --L)  sfile[L]=$2; shift 2 ;;
      --I)  sfile[I]=$2; shift 2 ;;
      --N)  sfile[N]=$2; shift 2 ;;
      --P)  sfile[P]=$2; shift 2 ;;
    esac
  done
  shift #(to get rid of the '--')
  sosroot=$1
}

# Call the parser
PARSE $(getopt -u --name=$pzero -o $sopts -l $lopts -- "$@")

# If any special option was used appropriately with a file, do that instead of other opts
if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
  :
# If BASH is not v4+ and special options were used, fail
elif [[ $BASH_VERSINFO -lt 4 && -n $sfile ]]; then
  echo "Special options require use of BASH associative arrays" >&2
  echo "i.e., BASH v4.0 or higher (RHEL6/Fedora11 and above)" >&2
  exit 32
# Use default view if no content options specified
elif [[ -z $opts ]]; then
  eval $XSOS_DEFAULT_VIEW
# Else, if "all" option specified, set full view
elif [[ -n $all ]]; then
  eval $XSOS_ALL_VIEW
fi

# If color should be enabled, taste the rainbow
if [[ $XSOS_COLORS == y && $BASH_VERSINFO -ge 4 ]]; then
  c[0]=$XSOS_COLOR_RESET
  c[H1]=$XSOS_COLOR_H1
  c[H2]=$XSOS_COLOR_H2
  c[H3]=$XSOS_COLOR_H3
  c[Imp]=$XSOS_COLOR_IMPORTANT
  c[Warn1]=$XSOS_COLOR_WARN1
  c[Warn2]=$XSOS_COLOR_WARN2
  c[Up]=$XSOS_COLOR_IFUP
  c[Down]=$XSOS_COLOR_IFDOWN
else
  unset c
fi


# ON TO THE CONTENT MODULE FUNCTIONS!
# -----------------------------------
# ===================================


DMIDECODE() {
  [[ -z $1 ]] && dmidecode=$(dmidecode 2>/dev/null) || dmidecode=$(<"$1")
  echo -e "${c[H1]}DMIDECODE${c[0]}"
  # Prints "<BIOS Vendor>, <BIOS Version>, <BIOS Release Date>"
  echo -e "${c[H2]}  BIOS:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /BIOS Information/' <<<"$dmidecode" |
    awk -F: '
      /Vendor:/       { Vendor      = $2 }
      /Version:/      { Version     = $2 }
      /Release Date:/ { ReleaseDate = $2 }
      END { printf "   %s, version%s,%s\n", Vendor, Version, ReleaseDate }
    '
  # Prints <SYSTEM Manufacturer>, <SYSTEM Product Name>, <SYSTEM Version>, <SYSTEM Serial Number>, <SYSTEM UUID>
  echo -e "${c[H2]}  System:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /System Information/' <<<"$dmidecode" |
    awk -F: -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
      /Manufacturer:/ { Mfr     = $2 }
      /Product Name:/ { Product = $2 }
      /Version:/      { Version = $2 }
      /Serial Number:/{ Serial  = $2 }
      /UUID:/         { UUID    = $2 }
      END {
        printf "    %sMfr:%s %s\n", H3, H0, Mfr
        printf "    %sProd:%s%s\n", H3, H0, Product
        printf "    %sVers:%s%s\n", H3, H0, Version
        printf "    %sSer:%s %s\n", H3, H0, Serial
        printf "    %sUUID:%s%s\n", H3, H0, UUID
      }
    '
  # Prints <CPU Manufacturer>, <CPU Family>, <CPU Current Speed>, <CPU Version>
  # Prints "<N> of <N> CPU sockets populated, <N> cores/<N> threads per CPU"
  # Prints "<N> total cores, <N> total threads"
  echo -e "${c[H2]}  CPU:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /Processor Information/' <<<"$dmidecode" |
    awk -F: -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
      /Status:/       { SumSockets ++; if ($2 ~ /Populated/) PopulatedSockets ++ }
      /Core Count:/   { SumCores   += $2; CoresPerCpu = $2 }
      /Thread Count:/ { SumThreads += $2; ThreadsPerCpu = $2 }
      /Manufacturer:/ { if ($2 ~ /^ *$/)         next; Mfr         = $2; gsub(/  */, " ", Mfr) }
      /Family:/       { if ($2 ~ /^ *$|Other/)   next; Family      = $2; gsub(/  */, " ", Family) }
      /Current Speed:/{ if ($2 ~ /^ *$|Unknown/) next; CpuFreq     = $2; gsub(/  */, " ", CpuFreq) }
      /Version:/      { if ($2 ~ /^ *$/)         next; Version     = $2; gsub(/  */, " ", Version) }
      END {
        printf "    %s%d of %d CPU sockets populated, %d cores/%d threads per CPU\n",
          H_IMP, PopulatedSockets, SumSockets, CoresPerCpu, ThreadsPerCpu
        printf "    %d total cores, %d total threads\n", SumCores, SumThreads, H0
        printf "    %sMfr:%s %s\n", H3, H0, Mfr
        printf "    %sFam:%s %s\n", H3, H0, Family
        printf "    %sFreq:%s%s\n", H3, H0, CpuFreq
        printf "    %sVers:%s%s\n", H3, H0, Version
      }
    '
  # Prints "<N> MB (<N> GB) total"
  # Prints "<N> of <N> DIMMs populated (max capacity <N>)"
  echo -e "${c[H2]}  Memory:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /Physical Memory Array|Memory Device/' <<<"$dmidecode" |
    awk -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
      /Size:/ { NumDimmSlots ++; if ($2 ~ /^[0-9]/) { NumDimms ++; SumRam+=$2 } }
      /Maximum Capacity:/ { MaxRam = $3" "$4 }
      END {
        printf "    %d MB (%.0f GB) total\n", SumRam, SumRam/1024
        printf "    %d of %d DIMMs populated (system max capacity %s)\n",
          NumDimms, NumDimmSlots, MaxRam
      }
    '
  echo -en $XSOS_HEADING_SEPARATOR
}


_CHECK_DISTRO() {
  OS_INDENT="             "
  # Parse redhat-release if we have it
  if [[ ! -r $1/etc/redhat-release ]]; then
    distrorelease="${c[Imp]}[redhat-release]${c[0]} ${c[RED]}(missing)${c[0]}"
    
  else
    # If release is RHEL 4,5,6 in standard expected format ...
    if egrep -e 'Red Hat Enterprise Linux (AS|ES|Desktop|WS) release 4 \((Nahant|Nahant Update [1-9])\)' \
             -e 'Red Hat Enterprise Linux (Client|Server) release 5\.?[0-9]* \(Tikanga\)' \
             -e 'Red Hat Enterprise Linux (Client|Workstation|Server) release 6\.?[0-9]* \(Santiago\)' \
             -qs "$1/etc/redhat-release"; then
    
      # ... And if redhat-release file has more than 1 line ...
      [[ $(wc -l <"$1/etc/redhat-release") -gt 1 ]] &&
      
        # ... Then print it in orange
        distrorelease=${c[ORANGE]}$(sed "1!s/^/$OS_INDENT/" <"$1/etc/redhat-release") ||
        
          # Otherwise, if only 1 line, all is well -- print it normally
          distrorelease=$(sed "1!s/^/$OS_INDENT/" <"$1/etc/redhat-release")
          
    # If release is not RHEL 4,5,6 in standard expected format, freak out
    else
      distrorelease=$(sed "1!s/^/$OS_INDENT/" "$1/etc/redhat-release" 2>/dev/null)
      
      if grep -qi fedora <<<"$distrorelease"; then
        distrorelease=${c[bg_BLUE]}$distrorelease
      
      elif egrep -qi 'alpha|beta' <<<"$distrorelease"; then
        distrorelease=${c[bg_RED]}${c[ORANGE]}$distrorelease
        
      else
        distrorelease=${c[bg_ORANGE]}${c[RED]}$distrorelease
      fi
    fi
    # Prepend the distro information with "[redhat-release] " and do a little color fun
    distrorelease="${c[Imp]}[redhat-release]${c[0]} $distrorelease${c[0]}"
  fi

  # Check for any /etc/*-release or /etc/*_version files and add their content to the distrorelease variable
  files=$(ls "$1"/etc/*{-release,_version} 2>/dev/null | egrep -sv '/etc/(os|redhat|system)-release')
  if [[ -n $files ]]; then
    for file in $files; do
      if [[ -r $file ]]; then
        distrorelease="$distrorelease\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} $(sed "1!s/^/$OS_INDENT/" <"$file")"
      elif [[ -L $file ]]; then
        distrorelease="$distrorelease\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} ${c[RED]}(error: broken link)${c[0]}"
      else
        distrorelease="$distrorelease\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} ${c[RED]}(error: file exists, but cannot read it)${c[0]}"
      fi
    done
  fi
  
  # If able to source the new standard /etc/os-release, list it out
  if source "$1/etc/os-release" 2>/dev/null; then
    distrorelease="$distrorelease\n$OS_INDENT${c[Imp]}[os-release]${c[0]} $PRETTY_NAME"
  fi
}


_CHECK_KERNELBUILD() {
  # Get kernel build version somehow or another, making sure not to use build offered by rescue mode kernel
  
  # if localhost: get it from the best place, yay
  if [[ $1 == / ]]; then
    kernel_build=$(</proc/version)
  
  # sosreport: sosreports don't normally contain this.. yet
  elif [[ -r "$1/proc/version" ]] && ! grep -qsw rescue "$1/proc/cmdline"; then
    kernel_build=$(<"$1/proc/version")
  
  # sosreport: if find it via `dmesg` output file, great
  elif ! grep -qsw rescue "$1/proc/cmdline" && kernel_build=$(grep -s 'Linux version' "$1/sos_commands/general/dmesg"); then
    :
    
  # sosreport: if find it in var/log/dmesg, woo hoo
  elif grep -qs 'Linux version' "$1/var/log/dmesg"; then
    kernel_build=$(grep 'Linux version' "$1/var/log/dmesg" | tail -n1)
  
  # sosreport: if find it in var/log/messages, lovely
  elif grep -qs 'kernel: Linux version' "$1/var/log/messages"; then
    kernel_build=$(grep 'kernel: Linux version' "$1/var/log/messages" | tail -n1)
  
  # sosreport: final option: search in all old messages files -- this might be a bad idea
  else
    # To explain this last one: The goal is to find the most recent instance of "Linux version"
    # So this reverse-sorts by filename, searches through all files ending with the most recent file
    # This is obviously not very efficient, but it's the only way I've thought of to do it so far
    kernel_build=$(find "$1/var/log" -name 'messages?*' 2>/dev/null | sort -r | xargs zgrep -sh 'kernel: Linux version' 2>/dev/null | tail -n1)
  fi
  
  # Fix format if necessary
  if [[ -n $kernel_build ]]; then
    kernel_build=$(sed -e 's,^\[.*\] Linux,Linux,' -e 's,^.*kernel: Linux,Linux,' <<<"$kernel_build")
    kernel_buildhost=$(awk '{print $4}' <<<"$kernel_build")
  fi
}


_CHECK_SELINUX() {
  # Grab input from sestatus command if localhost
  if [[ $1 == / ]]; then
    sestatus=$(sestatus)
    
  # Else, from $sosroot/sestatus or $sosroot/etc/selinux/config
  else
    sestatus=$(awk '!/\/.*bin/ && NF!=0' "$1/sestatus" 2>/dev/null) || {
      [[ -r $1/etc/selinux/config ]] && sestatus2=$(<"$1/etc/selinux/config")
      # Set "selinux" and "enforcing" variables per $sosroot's kernel args
      eval $(egrep -io 'selinux=.|enforcing=.' "$1/proc/cmdline" | tr 'A-Z' 'a-z')
    }
  fi
  
  # We have definitive sestatus command output
  if [[ -n $sestatus ]]; then
    awk '
      /SELinux status/                    { status  = $NF }
      /Current mode/                      { mode    = $NF }
      /Mode from config file/             { cfgmode = $NF }
      /Loaded policy|Policy from config/  { policy  = $NF }
      END { 
        if (status == "disabled") print status
        else printf "%s  (default %s)\n", mode, cfgmode
      }
    ' <<<"$sestatus"
    
  # Have /etc/selinux/config output
  elif [[ -n $sestatus2 ]]; then
    awk -F= -vselinux="$selinux" -venforcing="$enforcing" '
      /^SELINUX=/     { mode = $2 }
      /^SELINUXTYPE=/ { policy = $2 }
      END {
        if (mode == "disabled") {
          if (selinux == 1)
            printf "enforcing via kernel arg  (default %s)\n", mode
          else
            print "disabled"
        }
        else {
          if (selinux == 0)
            printf "disabled via kernel arg  (default %s)\n", mode
          else if (enforcing == 0)
            printf "permissive via kernel arg  (default %s)\n", mode
          else if (enforcing == 1)
            printf "enforcing via kernel arg  (default %s)\n", mode
          else
            printf "status unknown  (default %s)\n", mode
        }
      }
    ' <<<"$sestatus2"
    
  # Only have /proc/cmdline
  else
    if [[ -n $selinux ]]; then
      [[ $selinux -eq 0 ]] && echo "disabled via kernel arg  (default unknown)"
      [[ $selinux -eq 1 ]] && echo "enforcing via kernel arg  (default unknown)"
    elif [[ -n $enforcing ]]; then
      [[ $enforcing -eq 0 ]] && echo "permissive via kernel arg  (default unknown)"
      [[ $enforcing -eq 1 ]] && echo "enforcing via kernel arg  (default unknown)"
    else
      echo "status unknown  (default unknown)"
    fi
  fi
}


OSINFO() {
  
  # These functions just set variables for later use
  _CHECK_DISTRO "$1"
  _CHECK_KERNELBUILD "$1"
  
  # Grab number of cpus from proc/stat
  num_cpu=$(awk '/^cpu[[:graph:]]+/{n++} END{print n}' "$1/proc/stat" 2>/dev/null)
  
  # Grab btime (in seconds since U.Epoch) from proc/stat
  btime=$(awk '/^btime/{print $2}' "$1/proc/stat" 2>/dev/null)
  
  # Grab system hostname & kernel version from /proc first
  hostname=$(cat "$1/proc/sys/kernel/hostname" 2>/dev/null)
  kernel=$(cat "$1/proc/sys/kernel/osrelease" 2>/dev/null)
  
  # If running on localhost
  if [[ $1 == / ]]; then
    uname=$(uname -a | awk '{printf "mach=%s  cpu=%s  platform=%s\n", $(NF-3), $(NF-2), $(NF-1)}')
    systime=$(date)
    boottime=$(echo $(date --date=@$btime 2>/dev/null && echo " ($btime)"))
    uptime_input=$(uptime)
    runlevel=$(runlevel)
    initdefault=$(basename $(readlink -q /etc/systemd/system/default.target) 2>/dev/null) &&
      initdefault=${initdefault%.target} ||
        initdefault=$(awk -F: '/^id.*initdefault/ {print $2}' </etc/inittab)
    
  # Otherwise, running on sosreport
  else
    # If sosreport ran in rescue mode, try to get good hostname
    if grep -qsw rescue "$1/proc/cmdline"; then
      hostname=$(awk -F= /^HOSTNAME=/{print\$2}  "$1/etc/sysconfig/network" 2>/dev/null) ||
        hostname="${c[Warn1]}unknown${c[0]} (sosreport collected from rescue mode)"
    # Otherwise, if no hostname from proc/, try to get from sosroot/hostname or sosroot/uname
    else
      [[ -z $hostname ]] && {
        hostname=$(awk '!/\/.*bin/ && NF!=0' "$1/hostname" 2>/dev/null) ||
          hostname=$(awk '!/\/.*bin/ && NF!=0 {print $2}' "$1/uname" 2>/dev/null) ||
            hostname="${c[Warn1]}unknown${c[0]}"
      }
    fi
    # If sosreport ran in rescue mode, leave it to the kernel-build funness
    if grep -qsw rescue "$1/proc/cmdline"; then
      kernel="${c[Warn1]}unknown${c[0]} (sosreport collected from rescue mode -- see below)"
    # Otherwise, if no kernel version from proc/, try to get from sosroot/uname
    else
      [[ -z $kernel ]] && {
        kernel=$(awk '!/\/.*bin/ && NF!=0 {print $3}' "$1/uname" 2>/dev/null) ||
          kernel="${c[Warn1]}unknown${c[0]}"
      }
    fi
    uname=$(awk '!/\/.*bin/ && NF!=0 {printf "mach=%s  cpu=%s  platform=%s\n", $(NF-3), $(NF-2), $(NF-1)}' "$1/uname" 2>/dev/null) ||
        uname="${c[Warn1]}unknown${c[0]}"
    systime=$(awk '!/\/.*bin/ && NF!=0' "$1/date" 2>/dev/null)
    boottime=$(echo $(TZ=$(awk '!/\/.*bin/ && NF!=0 {print $5}' "$1/date" 2>/dev/null) date --date=@$btime 2>/dev/null && echo " ($btime)"))
    uptime_input=$(awk '!/\/.*bin/ && NF!=0' "$1/uptime")
    [[ -r $1/sos_commands/startup/runlevel ]] && runlevel=$(<"$1/sos_commands/startup/runlevel")
    [[ -r $1/etc/inittab ]] &&
      initdefault=$(awk -F: '/^id.*initdefault/ {print $2}' <"$1/etc/inittab") ||
        initdefault=unknown
  fi
  
  # Start printing stuff
  echo -e "${c[H1]}OS${c[0]}"
  echo -e "  ${c[H2]}Hostname:${c[0]}  $hostname"
  echo -e "  ${c[H2]}Distro:${c[0]}    $distrorelease"
  echo -e "  ${c[H2]}Kernel:${c[0]}    $kernel"
  echo -e "  ${c[H2]}Arch:${c[0]}      $uname"
  
  [[ -n $runlevel ]] &&
  echo -e "  ${c[H2]}Runlevel:${c[0]}  $runlevel  (default $initdefault)"
  echo -e "  ${c[H2]}SELinux:${c[0]}   $(_CHECK_SELINUX "$1")"
  
  [[ -n $systime ]] &&
  echo -e "  ${c[H2]}Sys time:${c[0]}  $systime"
  
  # Assuming have uptime input and detected num of cpus, print uptime, loadavg, etc
  [[ -n $uptime_input && -n $num_cpu ]] &&
  awk -vSYSTIME="$systime" -vBTIME="$boottime" -vNUM_CPU="$num_cpu" -vREDBOLD="${c[RED]}" -vRED="${c[red]}" -vORANGE="${c[orange]}" -vGREEN="${c[green]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
      !/load average/ { next }
      {
      Time = $1
      
      Uptime = gensub(/^ *[[:graph:]]+ up +(.+users?),.+/, "\\1", 1)
      
      Load[15] = $(NF)
      Load[5]  = $(NF-1)
      Load[1]  = $(NF-2)
      for (i in Load) {
        sub(/,/, "", Load[i])
        LP[i] = Load[i] * 100 / NUM_CPU
      }
      for (i in LP) {
        if (LP[i] < 70) Color[i] = GREEN
        if (LP[i] > 69) Color[i] = ORANGE
        if (LP[i] > 89) Color[i] = RED
        if (LP[i] > 99) Color[i] = REDBOLD
      }
      
      if (SYSTIME == "")
        printf "  %sSys time:%s  %s\n", H2, H0, Time
      printf   "  %sBoot time:%s %s\n", H2, H0, BTIME
      printf   "  %sUptime:%s    %s\n", H2, H0, Uptime
      printf   "  %sLoadAvg:%s   %s (%s%.0f%%%s), %s (%s%.0f%%%s), %s (%s%.0f%%%s)\n",
        H2, H0, Load[1], Color[1], LP[1], H0, Load[5], Color[5], LP[5], H0, Load[15], Color[15], LP[15], H0
    }' <<<"$uptime_input"
    
  # Print info from proc/stat
  [[ -n $btime ]] &&
  awk -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
    /^cpu / {
      TotalTime = $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9 + $10 + $11
      user    = $2 * 100 / TotalTime
      nice    = $3 * 100 / TotalTime
      sys     = $4 * 100 / TotalTime
      idle    = $5 * 100 / TotalTime
      iowait  = $6 * 100 / TotalTime
      irq     = $7 * 100 / TotalTime
      softirq = $8 * 100 / TotalTime
      steal   = $9 * 100 / TotalTime
     #guest      = $10
     #guest_nice = $11
    }
    /procs_running/ { procs_running = $2 }
    /procs_blocked/ { procs_blocked = $2 }
   
    END {
      printf "  %sCpu time since boot:%s\n    us %.0f%%, ni %.0f%%, sys %.0f%%, idle %.0f%%, iowait %.0f%%, irq %.0f%%, sftirq %.0f%%, steal %.0f%%\n",
        H2, H0, user, nice, sys, idle, iowait, irq, softirq, steal
      printf "  %sprocs_running (procs_blocked):%s\n    %d (%d)\n",
        H2, H0, procs_running, procs_blocked
    }
  ' <"$1/proc/stat"
  
  # Print kernel tainted-status
  echo -e "  ${c[H2]}Kernel taint-check:${c[0]} $(_CHECK_TAINTED "$1" H2)"

  # Print kernel cmdline from proc/cmdline
  echo -e "  ${c[H2]}Booted kernel cmdline:${c[0]}"
  # If rescue mode detected, print a warning
  grep -qsw rescue "$1/proc/cmdline" &&
    echo -e "${c[Warn1]}   (Rescue mode detected)${c[0]}"
  fold -sw$XSOS_FOLD_WIDTH "$1/proc/cmdline" 2>/dev/null | sed 's,^,    ,'
  
  # Print default grub title statement
  echo -e "  ${c[H2]}GRUB default kernel line:${c[0]}"
  if [[ -r $1/boot/grub/grub.conf ]]; then
    eval $(grep -qs ^default= "$1/boot/grub/grub.conf") || {
      default=0
      echo -e "${c[Warn1]}   (Warning: \"default=\" missing in grub.conf; showing first title instead)${c[0]}"
    }
    sed 's,^title,\n\n,' "$1/boot/grub/grub.conf" | grep -v ^[[:graph:]] | awk -vDEFAULT=$((default+2)) -vRS="\n\n " 'NR == DEFAULT {print}' | grep -o 'vmlinuz-.*' | fold -sw$XSOS_FOLD_WIDTH | sed 's,^,    ,'
  else
    echo -e "${c[Warn1]}    Unable to detect${c[0]}"
  fi
  
  # Print and format kernel version
  echo -e "  ${c[H2]}Kernel version/build:${c[0]}"
  # If kernel build was detected ...
  if [[ -n $kernel_build ]]; then
    # Print a notice if rescue mode
    grep -qsw rescue "$1/proc/cmdline" &&
      echo -e "${c[Warn1]}   (Rescue mode detected; build info captured from logs of last boot)${c[0]}"
    # Format it to fit properly
    kernel_build=$(fold -sw$XSOS_FOLD_WIDTH <<<"$kernel_build" | sed 's,^,    ,')
    # Change color to warning color (orange) if can't find "build.redhat.com"
    grep -qe '\.z900\.redhat\.com' -e '\.build\.redhat\.com' -e '\.bos\.redhat\.com' -e '\.perf\.redhat\.com' <<<"$kernel_buildhost" ||
      kernel_build="${c[Warn1]}$kernel_build${c[0]}"
    echo -e "$kernel_build"
  else
    echo -e "${c[Warn1]}    Unable to detect${c[0]}"
  fi
      
  echo -en $XSOS_HEADING_SEPARATOR
}


CPUINFO() {
  [[ -f $1 ]] && cpuinfo=$1 || cpuinfo=$1/proc/cpuinfo
  
  # Get model of cpu
  model_cpu=$(awk -F: '/^model name/{print $2; exit}' <"$cpuinfo")
  
  # If no model detected (e.g. on Itanium), try to use vendor+family
  [[ -z $model_cpu ]] && {
    vendor=$(awk -F: '/^vendor /{print $2; exit}' <"$cpuinfo")
    family=$(awk -F: '/^family /{print $2; exit}' <"$cpuinfo")
    model_cpu="$vendor$family"
  }
  
  # Clean up cpu model string
  model_cpu=$(sed -e 's,(R),,g' -e 's,(TM),,g' -e 's,  *, ,g' -e 's,^ ,,' <<<"$model_cpu")
  
  # Get number of logical processors
  num_cpu=$(awk '/^processor/{n++} END{print n}' <"$cpuinfo")
  
  # Get number of physical processors
  num_cpu_phys=$(grep '^physical id' <"$cpuinfo" | sort -u | wc -l)
  
  # If "physical id" not found, we cannot make any assumptions (Virtualization--)
  # But still, multiplying by 0 in some crazy corner case is bad, so set it to 1
  # If num of physical *was* detected, add it to the beginning of the model string
  [[ $num_cpu_phys == 0 ]] && num_cpu_phys=1 || model_cpu="$num_cpu_phys $model_cpu"
  
  # If number of logical != number of physical, try to get info on cores & threads
  if [[ $num_cpu != $num_cpu_phys ]]; then
    
    # Detect number of threads (logical) per cpu
    num_threads_per_cpu=$(awk '/^siblings/{print $3; exit}' <"$cpuinfo")
    
    # Two possibile ways to detect number of cores
    cpu_cores=$(awk '/^cpu cores/{print $4; exit}' <"$cpuinfo")
    core_id=$(grep '^core id' <"$cpuinfo" | sort -u | wc -l)
    
    # The first is the most accurate, if it works
    if [[ -n $cpu_cores ]]; then
      num_cores_per_cpu=$cpu_cores
    
    # If "cpu cores" doesn't work, "core id" method might (e.g. Itanium)
    elif [[ $core_id -gt 0 ]]; then
      num_cores_per_cpu=$core_id
    fi
    
    # If found info on cores, setup core variables for printing
    if [[ -n $num_cores_per_cpu ]]; then
      cores1="($((num_cpu_phys*num_cores_per_cpu)) CPU cores)"
      cores2=" / $num_cores_per_cpu cores"
    # If didn't find info on cores, assume single-core cpu(s)
    else
      cores2=" / 1 core"
    fi
    
    # If found siblings (threads), setup the variable for the final line
    [[ -n $num_threads_per_cpu ]] &&
      coresNthreads="\n  └─$num_threads_per_cpu threads${cores2} each"
  fi
  
  # Check important cpu flags
  # pae=physical address extensions  *  lm=64-bit  *  vmx=Intel hw-virt  *  svm=AMD hw-virt
  # ht=hyper-threading  *  aes=AES-NI  *  constant_tsc=Constant Time Stamp Counter
  cpu_flags=$(egrep -o "pae|lm|vmx|svm|ht|aes|constant_tsc" <"$cpuinfo" | sort -u | sed ':a;N;$!ba;s/\n/,/g')
  [[ -n $cpu_flags ]] && cpu_flags="(flags: $cpu_flags)"
  
  # Print it all out
  echo -e "${c[H1]}CPU${c[0]}"
  echo -e "  ${c[Imp]}${num_cpu} logical processors${c[0]} ${cores1}"
  echo -e "  ${model_cpu} ${cpu_flags} ${coresNthreads}"
  echo -en $XSOS_HEADING_SEPARATOR
}


MEMINFO() {
  [[ -f $1 ]] && meminfo=$1 || meminfo=$1/proc/meminfo
  echo -e "${c[H1]}MEMORY${c[0]}"
  if grep -qsw rescue "$1/proc/cmdline"; then
    echo -e "${c[Warn2]}  WARNING: RESCUE MODE DETECTED${c[0]}"
    echo -e "${c[Warn1]}  meminfo reflects rescue env; inspect sysctl.conf manually for HugePages${c[0]}"
  fi
  awk -vu="$XSOS_MEM_UNIT" -vcolor_warn="${c[Warn1]}" -vH_IMP="${c[Imp]}" -vH2="${c[H2]}" -vH0="${c[0]}" '
    
    # Grab variables from meminfo
    /^MemTotal:/        { MemTotal  = $2 }
    /^MemFree:/         { MemFree   = $2 }
    /^Buffers:/         { BuffCache += $2 }
    /^Cached:/          { BuffCache += $2 }
    /^SwapCached:/      { BuffCache += $2 }
    /^LowTotal:/        { LowTotal  = $2 }
    /^LowFree:/         { LowFree   = $2 }
    /^SwapTotal:/       { SwapTotal = $2 }
    /^SwapFree:/        { SwapFree  = $2 }
    /^Dirty:/           { Dirty     = $2 }
    /^Shmem:/           { Shmem     = $2 }
    /^Slab:/            { Slab      = $2 }
    /^PageTables:/      { PageTables      = $2 }
    /^Hugepagesize:/    { Hugepagesize    = $2 }
    /^HugePages_Total:/ { HugepagesTotal  = $2 }
    /^HugePages_Free:/  { HugepagesFree   = $2 }
    
    END {
      
      # Compute additional variables
      MemUsed         = MemTotal - MemFree
      Mem_Percent     = MemUsed * 100 / MemTotal
      MemUsedNoBC     = MemUsed - BuffCache
      MemNoBC_Percent = MemUsedNoBC * 100 / MemTotal
      Dirty_Percent   = Dirty * 100 / MemTotal
      Shmem_Percent   = Shmem * 100 / MemTotal
      Slab_Percent    = Slab * 100 / MemTotal
      PT_Percent      = PageTables * 100 / MemTotal
      HP              = Hugepagesize * HugepagesTotal
      HP_PercentRam   = HP * 100 / MemTotal
      
      # If have hugepages, calculate in-use
      if (HugepagesTotal > 0) {
        HP_Used         = (HugepagesTotal - HugepagesFree) * Hugepagesize
        HP_Used_Percent = (HugepagesTotal - HugepagesFree) * 100 / HugepagesTotal
      }
      # Else, need to avoid divide-by-zero errors
      else {
        HP_Used         = 0
        HP_Used_Percent = 0
      }
      
      # If meminfo has LowTotal (modern x86_64 boxes do not)...
      if (LowTotal ~ /[0-9]+/) {
        SHOW_Lowmem=1
        LowUsed         = LowTotal - LowFree
        LowUsed_Percent = LowUsed * 100 / LowTotal
      }
      # Else, avoid divide-by-zero and hide it
      else {
        SHOW_Lowmem=0
        LowTotal        = 0
        LowUsed         = 0
        LowUsed_Percent = 0
      }
      
      # If have swap-space...
      if (SwapTotal > 0) {
        SwapUsed      = SwapTotal - SwapFree
        Swap_Percent  = SwapUsed * 100 / SwapTotal
      }
      # Else, avoid divide-by-zero errors
      else {
        SwapUsed      = 0
        Swap_Percent  = 0
      }
      
      # If meminfo has Shmem, we show it; otherwise not
      if (Shmem ~ /[0-9]+/)
        SHOW_Shmem=1
      else
        SHOW_Shmem=0
      
      # If unit is set to megabytes or gigabytes,
      # do one round of division to convert to megabytes
      if (u == "m" || u == "g") {
        MemUsed     /= 1024
        MemTotal    /= 1024
        MemUsedNoBC /= 1024
        Dirty       /= 1024
        Shmem       /= 1024
        Slab        /= 1024
        PageTables  /= 1024
        HP          /= 1024
        if (HugepagesTotal > 0) HP_Used /= 1024
        if (LowTotal > 0) { LowUsed /= 1024; LowTotal /= 1024 }
        if (SwapTotal > 0) { SwapUsed /= 1024; SwapTotal /= 1024 }
      }
      
      # If unit is set to gigabytes, do an additional division round
      # and print units with 1 decimal-point of precision
      if (u == "g") {
        
        Unit = " GiB"
        
        MemUsed     /= 1024
        MemTotal    /= 1024
        MemUsedNoBC /= 1024
        Dirty       /= 1024
        Shmem       /= 1024
        Slab        /= 1024
        PageTables  /= 1024
        HP          /= 1024
        if (HugepagesTotal > 0) HP_Used /= 1024
        if (LowTotal > 0) { LowUsed /= 1024; LowTotal /= 1024 }
        if (SwapTotal > 0) { SwapUsed /= 1024; SwapTotal /= 1024 }
        
        printf    "  %sRAM:%s\n", H2, H0
        printf    "    %s%.1f%s total%s [%.1f%s (%.0f%%) used]\n", H_IMP, MemTotal, Unit, H0, MemUsed, Unit, Mem_Percent
        printf    "    %s%.1f%s (%.0f%%) used excluding buffers/cache%s\n", H_IMP, MemUsedNoBC, Unit, MemNoBC_Percent, H0
        if (Dirty_Percent > 5)
          printf  "    %s%.2f%s (%.0f%%) dirty%s\n", color_warn, Dirty, Unit, Dirty_Percent, H0
        else
          printf  "    %.2f%s (%.0f%%) dirty\n", Dirty, Unit, Dirty_Percent
        
        printf    "  %sHugePages:%s\n", H2, H0
        if (HugepagesTotal == 0)
          printf  "    ZERO ram pre-allocated to HugePages\n"
        else {
          printf  "    %s%.1f%s pre-allocated to HugePages (%.0f%% of total ram)%s\n", H_IMP, HP, Unit, HP_PercentRam, H0
          printf  "    %.1f%s of HugePages (%.0f%%) in-use by applications\n", HP_Used, Unit, HP_Used_Percent
        }
        
        printf    "  %sLowMem/Slab/PageTables/Shmem:%s\n", H2, H0
        if (SHOW_Lowmem == 1)
          printf  "    %.1f%s (%.0f%%) of %.1f%s LowMem in-use\n", LowUsed, Unit, LowUsed_Percent, LowTotal, Unit
        printf    "    %.2f%s (%.0f%%) of total ram used for Slab\n", Slab, Unit, Slab_Percent
        printf    "    %.2f%s (%.0f%%) of total ram used for PageTables\n", PageTables, Unit, PT_Percent
        if (SHOW_Shmem == 1)
          printf  "    %.2f%s (%.0f%%) of total ram used for Shmem\n", Shmem, Unit, Shmem_Percent
        
        printf    "  %sSwap:%s\n", H2, H0
        if (SwapTotal == 0)
          printf  "    %sZERO system swap space configured%s\n", color_warn, H0
        else
          printf  "    %.1f%s (%.0f%%) used of %.1f%s total\n", SwapUsed, Unit, Swap_Percent, SwapTotal, Unit
      }
      
      # Else, if unit is megabytes or kilobytes,
      # print units with 0 decimal-points of precision,
      # print percentages with an extra decimal-point of precision
      else {
        
        if (u == "m")
          Unit = " MiB"
        else
          Unit = " KiB"
        
        printf    "  %sRAM:%s\n", H2, H0
        printf    "    %s%.0f%s total%s [%.0f%s (%.1f%%) used]\n", H_IMP, MemTotal, Unit, H0, MemUsed, Unit, Mem_Percent
        printf    "    %s%.0f%s (%.1f%%) used excluding buffers/cache%s\n", H_IMP, MemUsedNoBC, Unit, MemNoBC_Percent, H0
        if (Dirty_Percent > 5)
          printf  "    %s%.0f%s (%.1f%%) dirty%s\n", color_warn, Dirty, Unit, Dirty_Percent, H0
        else
          printf  "    %.0f%s (%.1f%%) dirty\n", Dirty, Unit, Dirty_Percent
        
        printf    "  %sHugePages:%s\n", H2, H0
        if (HugepagesTotal == 0)
          printf  "    ZERO ram pre-allocated to HugePages\n"
        else {
          printf  "    %s%.0f%s pre-allocated to HugePages (%.1f%% of total ram)%s\n", H_IMP, HP, Unit, HP_PercentRam, H0
          printf  "    %.0f%s of HugePages (%.1f%%) in-use by applications\n", HP_Used, Unit, HP_Used_Percent
        }
        
        printf    "  %sLowMem/Slab/PageTables/Shmem:%s\n", H2, H0
        if (SHOW_Lowmem == 1)
          printf  "    %.0f%s (%.1f%%) of %.0f%s LowMem in-use\n", LowUsed, Unit, LowUsed_Percent, LowTotal, Unit
        printf    "    %.0f%s (%.1f%%) of total ram used for Slab\n", Slab, Unit, Slab_Percent
        printf    "    %.0f%s (%.1f%%) of total ram used for PageTables\n", PageTables, Unit, PT_Percent
        if (SHOW_Shmem == 1)
          printf  "    %.0f%s (%.1f%%) of total ram used for Shmem\n", Shmem, Unit, Shmem_Percent
        
        printf    "  %sSwap:%s\n", H2, H0
        if (SwapTotal == 0)
          printf  "    %sZERO system swap space configured%s\n", color_warn, H0
        else
          printf  "    %.0f%s (%.1f%%) used of %.0f%s total\n", SwapUsed, Unit, Swap_Percent, SwapTotal, Unit
      }
    }
  ' <"$meminfo"
  echo -en $XSOS_HEADING_SEPARATOR
}


STORAGE() {
  echo -e "${c[H1]}STORAGE${c[0]}"
  if [[ $2 == --mpath ]]; then
    # Get multipath input from command, because $1 is system
    if [[ $1 == / && $UID -eq 0 ]]; then
      mpath_input=$(multipath -v4 -ll 2>/dev/null)
    # Get multipath input from sosreport file, if present
    elif [[ -r $1/sos_commands/devicemapper/multipath_-v4_-ll ]]; then
      mpath_input=$(<"$1/sos_commands/devicemapper/multipath_-v4_-ll")
    else
      mpath_input=
    fi
  fi 
  # If multipath --mpath option requested + returned good data, check to see if there are paths
  # If so, print out the mpath devices and hide their children from the later disk printout
  scsi_blacklist=
  if [[ -n $mpath_input ]] && ! egrep -q 'no.paths|multipath.conf.*not.exist' <<<"$mpath_input"; then
    echo -e "${c[H2]}  Multipath:${c[0]}"
    grep -B1 '^\[size=' <<<"$mpath_input" |
      awk '
        BEGIN { RS = "--" }
        {
          printf "    %s@%s\n", $1,
            gensub(/.*\[size=([0-9]+\.?[0-9]*) ?([[:alpha:]]{1,2})\].*/, "\\1 \\2", 1)
        }
      ' | sort | column -ts@
    scsi_blacklist=$(awk '/\\_ .* sd[[:alpha:]]+ / {printf "%s|", $3}' <<<"$mpath_input")
  fi
  # Get linux software raid (mdstat) info from where?
  if [[ $1 == / ]]; then
    mdstat_input=/proc/mdstat
  # Get mdstat input from sosreport, if present
  elif [[ -r $1/proc/mdstat ]]; then
    mdstat_input=$1/proc/mdstat
  fi
  if [[ -n $mdstat_input ]]; then
    # Get raid_components
    raid_components=$(grep ^md "$mdstat_input" 2>/dev/null | cut -d\  -f5- | egrep -o '[[:alpha:]]+' | sort -u | awk '{printf "%s|", $1}')
    # Append software raid component disks to the blacklist
    scsi_blacklist=$scsi_blacklist$raid_components
  fi
# FIXME:
#  scsi_blacklist=$scsi_blacklist$(awk '
#    /^md./ {
#      printf gensub(/.* ([[:alpha:]]+)[0-9]*\[[0-9]+\] .*/, "\\1|", "g")
#    }' <"$mdstat_input")

  # Yay, let's go.
  [[ -n $scsi_blacklist ]] && bl=y || { bl=n; scsi_blacklist=NULL; }
  [[ -f $1 ]] && partitions=$1 || partitions=$1/proc/partitions
  echo -e "  ${c[H2]}Disks:${c[0]}"
  egrep -v "${scsi_blacklist%?}" "$partitions" |
    awk -vblacklisted=$bl '
      $4 ~ /^hd.$|^sd[[:alpha:]]+$|^md.$|^r+om.$|^r?flash.$|^rd\/c.{1,2}d.{1,2}$|^ida\/c.d.$|^i2o\/hd[[:alpha:]]+$|^amiraid\/ar.{1,2}$|cbd\/.$|^cciss\/c.d.{1,2}$|^iseries\/vd[[:alpha:]]+$|^ataraid\/d.{1,2}$|^emd\/.{1,2}$|^carmel\/.{1,2}$|^mmcblk.$|^ub.$|^xvd[[:alpha:]]+$|^vd[[:alpha:]]+$/ {
        numdisks ++
        disksize =  $3/1024/1024
        sum_gb   += disksize
        disk[$4] =  disksize
      }
      END {
        if (blacklisted == "y")
          print  "    (Multipath and/or software raid components hidden)"
        printf   "    %d disks, totaling %.0f GiB (%.2f TiB)\n", numdisks, sum_gb, sum_gb/1024
        n = asorti(disk, disk_sorted)
        for (i = 1; i <= n; i++)
          printf "    %s   %.1f G\n", disk_sorted[i], disk[disk_sorted[i]]
      }
    '
  echo -en $XSOS_HEADING_SEPARATOR
}


LSPCI() {
  if [[ -z $1 ]]; then
    lspci_input=$(lspci)
  elif [[ -f $1 ]]; then
    lspci_input=$(<"$1")
  else
    lspci_input=$(<"$1/lspci")
  fi

  echo -e "${c[H1]}LSPCI${c[0]}"

  awk -vH_IMP="${c[Imp]}" -vH2="${c[H2]}" -vH0="${c[0]}" '
    !/Ethernet controller:|Network controller:|Fibre Channel:|Mass storage controller:/ {
      next
    }
    {
      split($1, slot, ":")
      $1 = ""
      sub(" ", "")
      split($0, type, ":")
      dev[type[2]] ++
      if (!(slot[1] SUBSEP type[2] in slots)) {
        slots[slot[1], type[2]]
        slotcount[type[2]] ++
      }
    }
    END {
      printf "%s  Net/Storage:%s\n", H2, H0
      for (devtype in dev) {
        slotc = slotcount[devtype]
        typec = dev[devtype]
        ports = ""
        if (typec > 1) {
          numports = typec/slotc
          if      (numports == 1) numports = "single"
          else if (numports == 2) numports = "dual"
          else if (numports == 3) numports = "triple"
          else if (numports == 4) numports = "quad"
          ports = " "slotc " " numports "-port"
        }
        printf "   %s%s (%s)%s%s\n", H_IMP, ports, typec, H0, devtype
      }
    }
  ' <<<"$lspci_input"
  
  echo -e "${c[H2]}  VGA:${c[0]}"
  awk -F: '$2 ~ /^.... VGA/ { print "   "$3}' <<<"$lspci_input"
  echo -en $XSOS_HEADING_SEPARATOR
}


IPADDR() {
# I spent a long time wondering how I would end up implementing ip-addr functionality
# I couldn't think of a lovely elegant gawk-way and in the end I wrote this in 2 hours
# This is probably one of the most expensive of the functions

  # Require BASH v4
  if [[ -z $BASH_VERSINFO || $BASH_VERSINFO -lt 4 ]]; then
    echo "The -i/--ip option requires use of BASH associative arrays" >&2
    echo "i.e., BASH v4.0 or higher (RHEL6/Fedora11 and above)" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
    return
  fi

  # If localhost, use ip addr
  if [[ -z $1 ]]; then
    ip_addr=$(ip a)
  # If passed a file (i.e. xsos --I <file>), use that
  elif [[ -f $1 ]]; then
    ip_addr=$(<"$1")
  # Otherwise, use file from $sosroot
  else
    ip_addr=$(<"$1/sos_commands/networking/ip_address")
  fi
  
  # Prepare input for awk by separating each interface block
  ip_addr=$(sed -e 's,^[0-9]*: ,\n&,' -e '1s,^,\n,' <<<"$ip_addr")
  
  # Grab a list of the interface names
  ipdevs=$(awk -F: 'BEGIN {RS="\n\n"} {print $2}' <<<"$ip_addr" | egrep -v 'sit0')
  
  # Declare our 6 associative arrays
  declare -A ip_input slaveof ipv4 ipv4_alias state mac 
  
  # Begin ...
  echo -e "${c[H1]}IP${c[0]}"
  
  # The bracket here is like using parens to make a subshell -- allows to capture all stdout
  {
    # Header info ("~" is used later by `column` to columnize the output)
    echo "  Interface~Slave Of~IPv4 Address~State~MAC Address"
    echo "  =========~========~==================~=====~================="
    
    # For each interface ($i) found in ip addr output
    for i in $ipdevs; do
      
      # Pull out input for specific interface and save to interface key in array
      ip_input[$i]=$(awk "BEGIN {RS=\"\n\n\"} /^[0-9]+: $i:/" <<<"$ip_addr")
      
      # Figure out if $i is a slave of some bond device
      slaveof[$i]=$(grep -q SLAVE <<<"${ip_input[$i]}" && egrep -o 'master [[:graph:]]+' <<<"${ip_input[$i]}" | awk '{print $2}' || echo "-")
      
      # Get up/down state for $i
      state[$i]=$(grep -q "$i: .*,UP"  <<<"${ip_input[$i]}" && echo up || echo DOWN)
      
      # Get macaddr for $i (don't show if all zeros)
      mac[$i]=$(egrep -q 'link/[[:graph:]]+ ..:..:..:..:..:..' <<<"${ip_input[$i]}" && awk '/link\/[[:graph:]]+ ..:..:..:..:..:../ {if ($2 == "00:00:00:00:00:00") print "-"; else print $2}' <<<"${ip_input[$i]}" || echo "-")
      
      # If $i has an ipv4 address, time to figure out what it is
      if grep -q "inet .* ${i%@*}\$" <<<"${ip_input[$i]}"; then
        
        # We could potentially have more than one non-alias ipaddr...
        # So we need to set up a counter and do a loop
        n=0; while read ipv4addr; do
          if [[ $n -eq 0 ]]; then
            echo "  $i~${slaveof[$i]}~$ipv4addr~${state[$i]}~${mac[$i]}"
          else
            echo "   ~ ~$ipv4addr~ ~ "
          fi
          n=$((n+1))
        done <<<"$(awk "/inet .* ${i%@*}\$/ {print \$2}" <<<"${ip_input[$i]}")"
      
      # Otherwise, print out all info with ipv4 addr set to "-"
      else
        echo "  $i~${slaveof[$i]}~-~${state[$i]}~${mac[$i]}"
        # ... And Continue on to the next interface, i.e., skip looking for aliases
        continue
      fi

      # If $i had an ipv4 addr, it's ALIAS time!
      if grep -q "inet .* $i:" <<<"${ip_input[$i]}"; then
      
        # For each "alias" (additional address) found ...
        for alias in $(awk "/inet .* $i:/ {print \$NF}" <<<"${ip_input[$i]}"); do
          ipv4_alias[$alias]=$(awk "/inet .* $alias\$/ {print \$2}" <<<"${ip_input[$i]}")
          
          # ... Print out a new line with its ipv4 addr
          echo "  $alias~ ~${ipv4_alias[$alias]}~ ~ "
        done
      fi
      
    done
  } |
  
    # All output from above needs to be columnized
    column -ts~ |
    
      # And then we need to do some color funness!
      # This colorizes the first 2 lines with the H2 color and the interfaces with H3
      awk -vH0="${c[0]}" -vH2="${c[H2]}" -vH3="${c[H3]}" '
        {
          if (NR <= 2) print H2 $0 H0
          else printf gensub(/(^  [[:graph:]]+ )/,   H3"\\1"H0, 1)"\n"
        }'

  echo -en $XSOS_HEADING_SEPARATOR
}



ETHTOOL() {
  # If localhost, grab interfaces from /sys
  if [[ -z $1 ]]; then
    ethdevs=$(ls /sys/class/net | egrep -v 'lo|sit0')
    # Setup local functions for ethtool & ethtool -i
    __ethtool()   { ethtool $1; }
    __ethtool_i() { ethtool -i $1; }
    
  # If sosreport, determine interfaces from ethtool_<iface> files
  elif ls "$1"/sos_commands/networking/ethtool* &>/dev/null; then
    pushd "$1"/sos_commands/networking >/dev/null
    ethdevs=$(ls ethtool_[[:alpha:]]* | cut -d_ -f2)
    # Setup local functions for ethtool & ethtool -i
    __ethtool()   { cat ethtool_$1; }
    __ethtool_i() { [[ -r ethtool_-i_$1 ]] && cat ethtool_-i_$1; }
  
  # Otherwise, set ethdevs to null
  else
    ethdevs=
  fi
  
  # If have ethdevs to work on ...
  if [[ -n $ethdevs ]]; then
    echo -e "${c[H1]}ETHTOOL${c[0]}"
    for i in $ethdevs; do
      echo -e "  $i~$(__ethtool $i |
      awk '
        /Link detected:/    { link = $3; sub(/yes/, "up", link); sub(/no/, "DOWN", link) }
        /Speed:/            { spd = $2 }
        /Duplex:/           { dup = tolower($2) }
        /Auto-negotiation:/ { aneg = $2; sub(/on/, "Y", aneg); sub(/off/, "N", aneg) }
        END {
          if (link == "up" && spd != "")
            linkdetails = " "spd" "dup" (autoneg="aneg")"
          printf "link=%s%s~", link, linkdetails
        }
      '
      )$(__ethtool_i $i |
      awk '
        BEGIN { driver="UNKNOWN"; drv_vers=""; fw_vers="" }
        /^driver:/           { if ($2 != "") driver=$2 }
        /^version:/          { if ($2 != "") drv_vers=" v"$2 }
        /^firmware-version:/ { if ($2 != "") fw_vers=" / fw "$2 }
        END { printf "drv %s%s%s\n", driver, drv_vers, fw_vers }
      '
    )"
    done | column -ts~ |
      awk -vH0="${c[0]}" -vU="${c[Up]}" -vD="${c[Down]}" '/DOWN/{print D $0 H0}  /up/{print U $0 H0}'
    [[ ${PWD##*/} == networking ]] && popd >/dev/null
  fi
  echo -en $XSOS_HEADING_SEPARATOR
}


PROC_NET() {
  [[ -f $1 ]] && netdev=$1 || netdev=$1/proc/net/dev
  echo -e "${c[H1]}NETDEV${c[0]}"
  tail -n+3 "$netdev" | egrep -v 'lo:|sit0:' | sed 's,:, ,' |
    awk -vu=$(tr 'bkmgt' 'BKMGT' <<<$XSOS_NET_UNIT) '
      {
        Interface[$1] = $1
        RxBytes[$1]   = $2
        RxPackets[$1] = $3
        RxErrs[$1]    = $4
        RxDrop[$1]    = $5
        TxBytes[$1]   = $10
        TxPackets[$1] = $11
        TxErrs[$1]    = $12
        TxDrop[$1]    = $13
        if (u == "K" || u == "M" || u == "G" || u == "T") {
          U = u"iB"
          RxBytes[$1]   /= 1024
          TxBytes[$1]   /= 1024
        }
        if (u == "M" || u == "G" || u == "T") {
          Packets_Unit = "k"
          RxBytes[$1] /= 1024
          TxBytes[$1] /= 1024
          RxPackets[$1] /= 1000
          TxPackets[$1] /= 1000
        }
        if (u == "G" || u == "T") {
          Packets_Unit = "M"
          RxBytes[$1] /= 1024
          TxBytes[$1] /= 1024
          RxPackets[$1] /= 1000
          TxPackets[$1] /= 1000
        }
        if (u == "T") {
          Packets_Unit = "G"
          RxBytes[$1] /= 1024
          TxBytes[$1] /= 1024
          RxPackets[$1] /= 1000
          TxPackets[$1] /= 1000
        }
        if (U == "") U = "B"
      }
      END {
        print "  Interface~Rx"U"ytes~RxPackets~RxErrs~RxDrop~Tx"U"ytes~TxPackets~TxErrs~TxDrop"
        print "  =========~=========~=========~======~======~=========~=========~======~======"
        n = asorti(Interface, IF)
        for (i = 1; i <= n; i++)
          if (u == "T")
            printf "  %s~%.3f~%.2f%s~%d~%d~%.3f~%.2f%s~%d~%d\n",
              IF[i], RxBytes[IF[i]], RxPackets[IF[i]], Packets_Unit, RxErrs[IF[i]], RxDrop[IF[i]],
              TxBytes[IF[i]], TxPackets[IF[i]], Packets_Unit, TxErrs[IF[i]], TxDrop[IF[i]]
          else if (u == "G")
            printf "  %s~%.2f~%.1f%s~%d~%d~%.2f~%.1f%s~%d~%d\n",
              IF[i], RxBytes[IF[i]], RxPackets[IF[i]], Packets_Unit, RxErrs[IF[i]], RxDrop[IF[i]],
              TxBytes[IF[i]], TxPackets[IF[i]], Packets_Unit, TxErrs[IF[i]], TxDrop[IF[i]]
          else if (u == "M")
            printf "  %s~%.1f~%.0f%s~%d~%d~%.1f~%.0f%s~%d~%d\n",
              IF[i], RxBytes[IF[i]], RxPackets[IF[i]], Packets_Unit, RxErrs[IF[i]], RxDrop[IF[i]],
              TxBytes[IF[i]], TxPackets[IF[i]], Packets_Unit, TxErrs[IF[i]], TxDrop[IF[i]]
          else if (u == "K" || u == "B")
            printf "  %s~%.0f~%.0f%s~%d~%d~%.0f~%.0f%s~%d~%d\n",
              IF[i], RxBytes[IF[i]], RxPackets[IF[i]], Packets_Unit, RxErrs[IF[i]], RxDrop[IF[i]],
              TxBytes[IF[i]], TxPackets[IF[i]], Packets_Unit, TxErrs[IF[i]], TxDrop[IF[i]]
      }
    ' | column -ts~ |
      awk -vH0="${c[0]}" -vH2="${c[H2]}" -vH3="${c[H3]}" '
        {
          if (NR <= 2) print H2 $0 H0
          else printf gensub(/(^  [[:graph:]]+ )/,   H3"\\1"H0, 1)"\n"
        }'
#  if [[ -d $1 ]]; then
#    echo -en $XSOS_HEADING_SEPARATOR
#    echo -e "${c[H1]}SOCKSTAT${c[0]}"
#    awk -vS="  " -vH3="${c[H3]}" -vH0="${c[0]}" '
#      { printf gensub(/^(.*:)/, S H3"\\1"H0, 1)"\n" }' <"$1/proc/net/sockstat"
#  fi
  echo -en $XSOS_HEADING_SEPARATOR
}


_CHECK_TAINTED() {
  tainted=$(<"$1/proc/sys/kernel/tainted")
  if [[ $tainted -eq 0 ]]; then
    echo "0 (kernel untainted)"
    return
  else
    case $2 in
      H0) unset indent   ;;
      H1) indent="  "    ;;
      H2) indent="    "  ;;
      H3) indent="      "
    esac
    taintvals=$(
      for taint in 536870912 268435456 4096 2048 1024 512 256 128 64 32 16 8 4 2 1; do
        if [[ $tainted -gt $taint ]]; then
          printf "$taint "
          tainted=$((tainted-taint))
        elif [[ $tainted -eq $taint ]]; then
          printf "$taint "                                                                                     
          break
        fi
      done
    )
  fi
  # See /usr/share/doc/kernel-doc*/Documentation/sysctl/kernel.txt
  # Or linux/kernel/panic.c
  t[1]="Proprietary module has been loaded"
  t[2]="Module has been forcibly loaded"
  t[4]="SMP with CPUs not designed for SMP"
  t[8]="User forced a module unload"
  t[16]="System experienced a machine check exception"
  t[32]="System has hit bad_page"
  t[64]="Userspace-defined naughtiness"
  t[128]="Kernel has oopsed before"
  t[256]="ACPI table overridden"
  t[512]="Taint on warning"
  t[1024]="Modules from drivers/staging are loaded"
  t[2048]="Working around severe firmware bug"
  t[4096]="Out-of-tree module has been loaded"
  t[268435456]="Hardware is unsupported"
  t[536870912]="Technology Preview code is loaded"
  echo "$taintvals"
  for n in $taintvals; do
    echo "$indent${t[$n]}"
  done
}


SYSCTL() {
  # VM PageSize (don't know how to find this from a sosreport, but I doubt that will often be a problem)
  [[ $1 == / ]] && pgsz=$(getconf PAGESIZE) || pgsz=4
  echo -e "${c[H1]}SYSCTLS${c[0]}"
  if grep -qsw rescue "$1/proc/cmdline"; then
    echo -e "${c[Warn2]}  WARNING: RESCUE MODE DETECTED${c[0]}"
    echo -e "${c[Warn1]}  sysctls below reflect rescue env; inspect sysctl.conf manually${c[0]}"
  fi
  echo -e "  ${c[H2]}kernel.${c[0]}
    ${c[H3]}osrelease:${c[0]} $(<"$1/proc/sys/kernel/osrelease")
    ${c[H3]}tainted:${c[0]} $(_CHECK_TAINTED "$1" H3)
    ${c[H3]}random.boot_id:${c[0]} $(<"$1/proc/sys/kernel/random/boot_id")
    ${c[H3]}random.entropy_avail:${c[0]} $(<"$1/proc/sys/kernel/random/entropy_avail")
    ${c[H3]}panic:${c[0]} $(<"$1/proc/sys/kernel/panic") (seconds til reboot after panic)
    ${c[H3]}hung_task_panic:${c[0]} $(<"$1/proc/sys/kernel/hung_task_panic")
    ${c[H3]}panic_on_oops:${c[0]} $(<"$1/proc/sys/kernel/panic_on_oops")
    ${c[H3]}panic_on_unrecovered_nmi:${c[0]} $(<"$1/proc/sys/kernel/panic_on_unrecovered_nmi")
    ${c[H3]}sysrq:${c[0]} $(<"$1/proc/sys/kernel/sysrq")
    ${c[H3]}sem:${c[0]} $(awk -vS="$H3INDENT" '{print $1,$2,$3,$4; printf "%smax semaphores per array = %d\n%smax sems system-wide     = %d\n%smax ops per semop call   = %d\n%smax number of arrays     = %d\n", S,$1,S,$2,S,$3,S,$4}' <"$1/proc/sys/kernel/sem")
    ${c[H3]}shmall (pages):${c[0]} $(<"$1/proc/sys/kernel/shmall") ($(awk -vPGSZ="$pgsz" '{printf "%.1f G max total shared memory\n", $1*PGSZ/1024/1024}' <"$1/proc/sys/kernel/shmall"))
    ${c[H3]}shmmax (bytes):${c[0]} $(<"$1/proc/sys/kernel/shmmax") ($(awk '{printf "%.2f G max segment size\n", $1/1024/1024/1024}' <"$1/proc/sys/kernel/shmmax"))
    ${c[H3]}shmmni (segments):${c[0]} $(<"$1/proc/sys/kernel/shmmni") (max number of segs)
  ${c[H2]}vm.${c[0]}
    ${c[H3]}dirty_ratio:${c[0]} $(<"$1/proc/sys/vm/dirty_ratio") %
    ${c[H3]}dirty_background_ratio:${c[0]} $(<"$1/proc/sys/vm/dirty_background_ratio") %
    ${c[H3]}dirty_bytes:${c[0]} $(<"$1/proc/sys/vm/dirty_bytes") b
    ${c[H3]}dirty_background_bytes:${c[0]} $(<"$1/proc/sys/vm/dirty_background_bytes") b
    ${c[H3]}dirty_expire_centisecs:${c[0]} $(<"$1/proc/sys/vm/dirty_expire_centisecs")
    ${c[H3]}dirty_writeback_centisecs:${c[0]} $(<"$1/proc/sys/vm/dirty_writeback_centisecs")
    ${c[H3]}nr_hugepages:${c[0]} $(<"$1/proc/sys/vm/nr_hugepages") pages
    ${c[H3]}overcommit_memory:${c[0]} $(<"$1/proc/sys/vm/overcommit_memory")
    ${c[H3]}overcommit_ratio:${c[0]} $(<"$1/proc/sys/vm/overcommit_ratio") %
    ${c[H3]}panic_on_oom:${c[0]} $(<"$1/proc/sys/vm/panic_on_oom")
  ${c[H2]}net.${c[0]}
    ${c[H3]}ipv4.icmp_echo_ignore_all:${c[0]} $(<"$1/proc/sys/net/ipv4/icmp_echo_ignore_all")
    ${c[H3]}ipv4.ip_forward:${c[0]} $(<"$1/proc/sys/net/ipv4/ip_forward")
    ${c[H3]}ipv4.tcp_max_orphans (sockets):${c[0]} $(<"$1/proc/sys/net/ipv4/tcp_max_orphans") ($(awk '{printf "%d M @ max 64 K per orphan\n", $1*64/1024}' <"$1/proc/sys/net/ipv4/tcp_max_orphans"))
    ${c[H3]}ipv4.tcp_mem (pages):${c[0]} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_mem") ($(awk -vPGSZ="$pgsz" '{printf "%.2f G, %.2f G, %.2f G\n", $1*PGSZ/1024/1024,$2*PGSZ/1024/1024,$3*PGSZ/1024/1024}' <"$1/proc/sys/net/ipv4/tcp_mem"))
    ${c[H3]}ipv4.udp_mem (pages):${c[0]} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/udp_mem") ($(awk -vPGSZ="$pgsz" '{printf "%.2f G, %.2f G, %.2f G\n", $1*PGSZ/1024/1024,$2*PGSZ/1024/1024,$3*PGSZ/1024/1024}' <"$1/proc/sys/net/ipv4/udp_mem"))
    ${c[H3]}ipv4.tcp_rmem (bytes):${c[0]} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_rmem") ($(awk '{printf "%d K, %d K, %d K\n", $1/1024,$2/1024,$3/1024}' <"$1/proc/sys/net/ipv4/tcp_rmem"))
    ${c[H3]}ipv4.tcp_wmem (bytes):${c[0]} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_wmem") ($(awk '{printf "%d K, %d K, %d K\n", $1/1024,$2/1024,$3/1024}' <"$1/proc/sys/net/ipv4/tcp_wmem"))
    ${c[H3]}ipv4.udp_rmem_min (bytes):${c[0]} $(<"$1/proc/sys/net/ipv4/udp_rmem_min") ($(awk '{printf "%d K\n", $1/1024}' <"$1/proc/sys/net/ipv4/udp_rmem_min"))
    ${c[H3]}ipv4.udp_wmem_min (bytes):${c[0]} $(<"$1/proc/sys/net/ipv4/udp_wmem_min") ($(awk '{printf "%d K\n", $1/1024}' <"$1/proc/sys/net/ipv4/udp_wmem_min"))"
  echo -en $XSOS_HEADING_SEPARATOR
}


PSCHECK() {
  # Get input from proper place dependent on what was passed
  if [[ -z $1 ]]; then
    input=$(ps aux)
  elif [[ -f $1 ]]; then
    input=$(awk '!/\/.*bin/ && NF!=0' "$1")
  else
    input=$(awk '!/\/.*bin/ && NF!=0' "$1/ps")
  fi
  
  # Verbosity? We den need no stinkin' verbosity!
  if [[ $XSOS_PS_LEVEL == 0 ]]; then
    # V-level 0: Less than default
    num_top_users=3
    num_comm_args=0
    num_process_lines=5
    process_line_length=100
  elif [[ -z $XSOS_PS_LEVEL || $XSOS_PS_LEVEL == 1 ]]; then
    # V-level 1: Default
    num_top_users=10
    num_comm_args=2
    num_process_lines=10
    process_line_length=150
  elif [[ $XSOS_PS_LEVEL == 2 ]]; then
    # V-level 2: Verbose
    num_top_users=30
    num_comm_args=10
    num_process_lines=30
    process_line_length=512
  elif [[ $XSOS_PS_LEVEL == 3 ]]; then
    # V-level 3: MOOOAAAARR
    num_top_users=60
    num_comm_args=1023
    num_process_lines=60
    process_line_length=2047  # This is the max that `column` can handle
  elif [[ $XSOS_PS_LEVEL == 4 ]]; then
    # V-level 4: Eerrryting
    num_top_users=
    num_comm_args=1023
    num_process_lines=
    process_line_length=2047  # This is the max that `column` can handle
  fi
  
  __conditional_head() {
  [[ -n $1 ]] &&
    echo head -n$1 ||
    echo cat  
  }
  
  # Perfectly columnize ps input and chop off extra command args based on above options
  input=$(awk -vMAX_fields=$((num_comm_args+12)) '{for (i=1; i<11; i++) printf $i"~"; for (i=11; i<=NF && i<MAX_fields; i++) printf $i" "; printf "\n"}' <<<"$input" | cut -c-$process_line_length | column -ts~ | sed 's,^,    ,')
  # Deal with header
  ps_header=$(head -n1 <<<"$input")
  ps_input=$(tail -n+2 <<<"$input")
  
  # Format and prepare sleeping/zombie processes
  Dsleepers=$(awk -vcolor_warn="${c[Warn1]}" -vc_0="${c[0]}" '$8~/D/ {print color_warn $0 c_0}' <<<"$ps_input")
  Zombies=$(awk -vc_grey="${c[GREY]}" -vc_0="${c[0]}" '$8~/Z/ {print c_grey $0 c_0}' <<<"$ps_input")
  [[ -n $Dsleepers ]] && Dsleepers="\n$Dsleepers"
  [[ -n $Zombies ]] && Zombies="\n$Zombies"
  [[ -z $Dsleepers && -z $Zombies ]] && Dsleepers="\n      ${c[grey]}(None)${c[0]}"
  
  # Calculte top cpu-using & mem-using users
  if [[ $XSOS_PS_LEVEL < 3 ]]; then  # If verbosity level 0-2, restrict number of users shown
    top_users=$(awk 'BEGIN{print "USER~%CPU~%MEM~RSS"} {pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6} END {for (user in pCPU) if (pCPU[user]>0 || sRSS[user]>4096) printf "%s~%.1f%%~%.1f%%~%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/1024/1024 }' <<<"$ps_input" | column -ts~ | sed 's,^,    ,')
    top_users_header=$(head -n1 <<<"$top_users")
  else  # If verbosity level 3-4, show all users
    top_users=$(awk 'BEGIN{print "USER~%CPU~%MEM~RSS"} {pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6} END {for (user in pCPU) printf "%s~%.1f%%~%.1f%%~%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/1024/1024 }' <<<"$ps_input" | column -ts~ | sed 's,^,    ,')
    top_users_header=$(head -n1 <<<"$top_users")
  fi
  top_users=$(tail -n+2 <<<"$top_users" | sort -rnk2 | $(__conditional_head $num_top_users))
  
  # Print!
  echo -e "${c[H1]}PS CHECK${c[0]}
  ${c[H2]}Top users of CPU & MEM:${c[0]} \n${c[H3]}$top_users_header${c[0]} \n$top_users
  ${c[H2]}Uninteruptible sleep & Defunct processes:${c[0]} \n${c[H3]}$ps_header${c[0]} $Dsleepers $Zombies
  ${c[H2]}Top CPU-using processes:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk3 <<<"$ps_input" | $(__conditional_head $num_process_lines))
  ${c[H2]}Top MEM-using processes:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk4 <<<"$ps_input" | $(__conditional_head $num_process_lines))"
  echo -en $XSOS_HEADING_SEPARATOR
}


#-------------------------------------------------------------------------------
# BLEH
# Eventually I'll probably replace all of this with a python loader.
# Python's argparse is so much better than dealing with all this crap.

# Used to conditionally run certain functions when running on localhost
COND_RUN() {
  if [[ $2 ==  --require_root && $UID != 0 ]]; then
    echo -e "${c[Warn1]}Warning: Need root access to run $1 command on localhost${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  elif command -v $1 &>/dev/null; then
    # The following tr command translates $1 to the uppercase function name, e.g. lspci --> LSPCI
    # In a BASHv4-only world, this could be done with simply: ${1^^}
    $(tr '[:lower:]' '[:upper:]' <<<"$1")
  else
    echo -e "${c[Warn1]}Warning: $1 command not present in PATH${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  fi
}


# If special options and files were provided ....
if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
  [[ -r ${sfile[B]} ]] && DMIDECODE "${sfile[B]}"
  [[ -r ${sfile[C]} ]] && CPUINFO   "${sfile[C]}"
  [[ -r ${sfile[M]} ]] && MEMINFO   "${sfile[M]}"
  [[ -r ${sfile[D]} ]] && STORAGE   "${sfile[D]}"
  [[ -r ${sfile[L]} ]] && LSPCI     "${sfile[L]}"
  [[ -r ${sfile[I]} ]] && IPADDR    "${sfile[I]}"
  [[ -r ${sfile[N]} ]] && PROC_NET  "${sfile[N]}"
  [[ -r ${sfile[P]} ]] && PSCHECK   "${sfile[P]}"

# If SOSREPORT-ROOT provided, use that
elif [[ -n $sosroot ]]; then
  if [[ -n $bios ]]; then
    if [[ -r $sosroot/dmidecode ]]; then
      DMIDECODE "$sosroot/dmidecode"
    elif [[ -r $sosroot/sos_commands/kernel.dmidecode ]]; then
      DMIDECODE "$sosroot/sos_commands/kernel.dmidecode"
    fi
  fi
  [[ -n $os && -d $sosroot/proc ]] &&                       OSINFO "$sosroot"
  [[ -n $cpu   && -r $sosroot/proc/cpuinfo ]] &&            CPUINFO "$sosroot"
  [[ -n $mem   && -r $sosroot/proc/meminfo ]] &&            MEMINFO "$sosroot"
  [[ -n $disks && -r $sosroot/proc/partitions ]] &&         STORAGE "$sosroot" --mpath
  [[ -n $lspci && -r $sosroot/lspci ]] &&                   LSPCI "$sosroot"
  [[ -n $ethtool ]] &&                                      ETHTOOL "$sosroot"
  [[ -n $ip && -r $sosroot/sos_commands/networking/ip_address ]] &&
                                                            IPADDR "$sosroot"
  [[ -n $net && -d $sosroot/proc/net ]] &&                  PROC_NET "$sosroot"
  [[ -n $sysctl && -d $sosroot/proc/sys ]] &&               SYSCTL "$sosroot" 2>/dev/null
  [[ -n $ps && -r $sosroot/ps ]] &&                         PSCHECK "$sosroot"
  
# If no SOSREPORT-ROOT provided, run checks against local system
else
  [[ -n $bios ]] &&    COND_RUN dmidecode --require_root
  [[ -n $os ]] &&      OSINFO /
  [[ -n $cpu ]] &&     CPUINFO /
  [[ -n $mem ]] &&     MEMINFO /
  [[ -n $disks ]] &&   STORAGE / --mpath
  [[ -n $lspci ]] &&   COND_RUN lspci
  [[ -n $ethtool ]] && COND_RUN ethtool --require_root
  [[ -n $ip ]] &&      IPADDR
  [[ -n $net ]] &&     PROC_NET /
  [[ -n $sysctl ]] &&  SYSCTL / 2>/dev/null
  [[ -n $ps ]] &&      PSCHECK

fi

