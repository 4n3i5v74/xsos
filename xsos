#!/bin/bash
# xsos v0.0.0y last mod 2012/08/25
# Latest version at <http://github.com/ryran/xsos>
# Copyright 2012 Ryan Sawhill <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------

# So much still to do ... Suggestions always welcome though.

# To make it easy to rename the script filename
pzero=${0##*/}

# Get version from line #2
version=$(sed '2q;d' $0)

# mem_unit can be k, m, or g and is used by the meminfo-code
# Change the default here to avoid having to use cmd-line options
# You can also change the formatting to suit your preference, e.g.
#   mem_unit=" GiB"
# If you change it like that, you'll need to tweak 2 of the meminfo
# awk command's if statements to account for that.
mem_unit="g"

# Variables used a few times for indentation
H2INDENT="    "
H3INDENT="      "

# Colors and colors and colors oh my
reset='\033[0;0m'; grey='\033[00;30m'; GREY='\033[01;30m'; red='\033[0;31m'; RED='\033[1;31m';
green='\033[0;32m'; GREEN='\033[1;32m'; orange='\033[0;33m'; ORANGE='\033[1;33m'; blue='\033[0;34m';
BLUE='\033[1;34m'; purple='\033[0;35m'; PURPLE='\033[1;35m'; cyan='\033[0;36m'; CYAN='\033[1;36m'


USAGE() {
  echo "Usage: $pzero [-xKMabocmdplenks] [SOSREPORT-ROOT]"
  echo "  or:  $pzero -?|-h|--help"
}


XHELP() {
  USAGE
  echo "
Print info about system from SOSREPORT-ROOT, or else current system

Display options:"
  echo "
 -x, --nocolor@disable coloring of output
 -K, --kb@show /proc/meminfo in KiB
 -M, --mb@show /proc/meminfo in MiB" | column -ts@
 echo "
Content options:"
  echo "
 -a, --all@show everything
 -b, --bios@show info from dmidecode
 -o, --os@show os release, kernel version, hostname, uptime
 -c, --cpu@show info from /proc/cpuinfo
 -m, --mem@show info from /proc/meminfo
 -d, --disks@show info from /proc/partitions
 -p, --mpath@show info from multipath
 -l, --lspci@show info from lspci
 -e, --ethtool@show info from ethtool
 -n, --net@show info from /proc/net/dev
 -k, --kern@show add'l /proc entries, e.g. stat, cmdline
 -s, --sysctl@show important kernel sysctls" | column -ts@
  echo "
Notes:

If no content options are specified, $pzero only shows some information,
equivalent to running it as follows:

  $pzero --os --cpu --mem --lspci
  
If SOSREPORT-ROOT isn't provided, current system's info will be printed;
however, bios, multipath, and ethtool output will only be displayed if running
as root (UID 0). When executing in this manner as non-root, those modules will
be silently skipped, even if explicitly requested.

Version info: ${version:2}
Report bugs or suggestions to <rsaw@redhat.com>
Or see <github.com/ryran/xsos> for bug tracker & latest version
Alternatively, run $pzero with '--update'"
  exit
}


UPDATE() {
  echo -e "${blue}Checking $0 against latest version at github.com/ryran/xsos ...${GREY}\n"
  latest_version_file=$(mktemp /tmp/xsos_latest.XXX)
  trap "rm $latest_version_file" EXIT

  # Download latest version of xsos with wget or curl
  if command -v wget >/dev/null; then
    wget https://raw.github.com/ryran/xsos/master/xsos -O $latest_version_file
  elif command -v curl >/dev/null; then
    curl https://raw.github.com/ryran/xsos/master/xsos -o $latest_version_file; echo
  else
    echo -e "${RED}Need either wget or curl in \$PATH to perform the download!${reset}"
    exit 255
  fi
  
  # Save version string
  latest_version=$(sed '2q;d' $latest_version_file)

  # Compare currently running xsos with downloaded file
  if ! diff $0 $latest_version_file >/dev/null; then
    echo -e "${blue}The version you are running reports as:\n\t${orange}${version:2}${blue}\nThe version on github appears to be different and reports as:\n\t${ORANGE}${latest_version:2}${blue}"
    echo -e "Would you like to see differences between them? (${GREEN}y${blue} or ${GREEN}n${blue})${reset}"
    read -p "> "
    if [[ $REPLY == y ]]; then
      if [[ -n $DISPLAY ]] && command -v meld >/dev/null; then
        meld $0 $latest_version_file
      elif [[ -n $DISPLAY ]] && command -v gvimdiff >/dev/null; then
        gvimdiff $0 $latest_version_file
      elif command -v vimdiff; then
        vimdiff $0 $latest_version_file
      else
        # set name of tmp diff file
        diff_file=$(mktemp /tmp/xsos.XXX.patch); trap "rm $diff_file" EXIT;
        # create a diff file
        diff -u $0 $latest_version_file > $diff_file
        if [[ -n $DISPLAY ]] && command -v gedit >/dev/null; then
          gedit $diff_file
        else
          less $diff_file
        fi
      fi
    fi
    echo -e "${blue}If you are sure you know what you are doing, type ${GREEN}update${blue}\nto replace $0 with the latest version${GREEN}"
    read -p "> "
    if [[ $REPLY == update ]]; then
      echo -e "${blue}Backing up current version and replacing it with downloaded version ...${cyan}"
      cp -v $0 /tmp/xsos.orig
      cp -v $latest_version_file $0
      chmod +x $0
      echo -e "${reset}"
    else
      echo -e "${cyan}Not performing update${reset}\n"
    fi
  else
    echo -e "${blue}$0 is the same version as what is on github, i.e.,\n\t${BLUE}${version:2}${reset}\n"
  fi
  exit
}


# Check for help query
case $1 in
  -h|--help|-\?) XHELP
;;
  --update) UPDATE
esac

# GNU getopt short and long options:
sopts='xKMabocmdplenks'
lopts='nocolor,kb,mb,all,bios,os,cpu,mem,disks,mpath,lspci,ethtool,net,kern,sysctl'

# Check for bad switches
getopt -Q --name=$pzero -o $sopts -l $lopts -- "$@" || { USAGE; exit 1; }

# Parse command-line arguments
PARSE() {
  unset opts nocolor kb mb all bios os cpu mem disks mpath lspci ethtool net kern sysctl
  until [[ $1 = -- ]]; do
    case $1 in
      -x|--nocolor) shift; nocolor=y
    ;;
      -K|--kb)      shift; mem_unit="k"
    ;;
      -M|--mb)      shift; mem_unit="m"
    ;;
      -a|--all)     shift; opts=y; all=y
    ;;
      -b|--bios)    shift; opts=y; bios=y
    ;;
      -o|--os)      shift; opts=y; os=y
    ;;
      -c|--cpu)     shift; opts=y; cpu=y
    ;;
      -m|--mem)     shift; opts=y; mem=y
    ;;
      -d|--disks)   shift; opts=y; disks=y
    ;;
      -p|--mpath)   shift; opts=y; mpath=y
    ;;
      -l|--lspci)   shift; opts=y; lspci=y
    ;;
      -e|--ethtool) shift; opts=y; ethtool=y
    ;;
      -n|--net)     shift; opts=y; net=y
    ;;
      -k|--kern)    shift; opts=y; kern=y
    ;;
      -s|--sysctl)  shift; opts=y; sysctl=y
    ;;
    esac
  done
  shift #(to get rid of the '--')
  sosroot=$1
}

# Call the parser
PARSE $(getopt -u --name=$pzero -o $sopts -l $lopts -- "$@")

# Set default view if no content options specified
if [[ -z $opts ]]; then
  os=y; cpu=y; mem=y; lspci=y
# Else, if "all" option specified, set full view
elif [[ -n $all ]]; then
  bios=y; os=y; cpu=y; mem=y; disks=y; mpath=y; lspci=y; ethtool=y; net=y; kern=y; sysctl=y
fi


# Uncomment the following if you'd like to disable colors by default
# nocolor=y

# If color should be disabled, don't initialize colors
if [[ $nocolor == y ]]; then
  unset c_0 c_h1 c_h2 c_h3 c_imp c_sep c_up c_down
# Taste the rainbow
else
  c_0=$reset
  c_h1=$RED
  c_h2=$PURPLE
  c_h3=$blue
  c_imp=$cyan
  c_sep=$GREY
  c_up=$green
  c_down=$orange
fi

# The following acts as a separator between content modules.
# Feel free to comment it out if you don't like it
heading_separator="$c_sep-------------------------------------------------------------------------------$c_0\n"


DMIDECODE() {
  [[ -z $1 ]] && dmidecode=$(dmidecode) || dmidecode=$(<"$1")
  echo -e "${c_h1}BIOS${c_0}"
  # Prints "<Manufacturer> <Product Name>, <Version>"
  echo -e "${c_h2}  System:${c_0}"
  awk 'BEGIN { RS="\nHandle" } /System Information/' <<<"$dmidecode" |
    awk -F: '
      /Manufacturer:/ { Mfr = $2 }
      /Product Name:/ { Product = $2 }
      /Version:/      { Version = $2 }
      END { printf "   %s%s, version%s\n", Mfr, Product, Version }
    '
  # Prints "<N> of <N> CPU sockets populated, <N> cores/<N> threads per CPU"
  # Prints "<N> total cores, <N> total threads"
  echo -e "${c_h2}  CPUs:${c_0}"
  awk 'BEGIN { RS="\nHandle" } /Processor Information/' <<<"$dmidecode" |
    awk -F: '
      /Status:/       { SumSockets ++; if ($2 ~ /Populated/) PopulatedSockets ++ }
      /Core Count:/   { SumCores += $2; CoresPerCpu = $2 }
      /Thread Count:/ { SumThreads += $2; ThreadsPerCpu = $2 }
      /Manufacturer:/ { Mfr = $2 }
      /Family:/       { Family = $2 }
      /Current Speed:/{ CpuFreq = $2 }
      /Max Speed:/    { CpuFreqMax = $2 }
      /Version:/      { Version = $2 }
      END {
        printf "   %s%s @%s (max supported CPU frequency%s)\n",
          Mfr, Family, CpuFreq, CpuFreqMax
        printf "    version%s\n", Version
        printf "    %d of %d CPU sockets populated, %d cores/%d threads per CPU\n",
          PopulatedSockets, SumSockets, CoresPerCpu, ThreadsPerCpu
        printf "    %d total cores, %d total threads\n", SumCores, SumThreads
      }
    '
  # Prints "<N> MB (<N> GB) total"
  # Prints "<N> of <N> DIMMs populated (max capacity <N>)"
  echo -e "${c_h2}  Memory:${c_0}"
  awk 'BEGIN { RS="\nHandle" } /Physical Memory Array|Memory Device/' <<<"$dmidecode" |
    awk '
      /Size:/ { NumDimmSlots ++; if ($2 ~ /^[0-9]/) { NumDimms ++; SumRam+=$2 } }
      /Maximum Capacity:/ { MaxRam = $3" "$4 }
      END {
        printf "    %d MB (%.0f GB) total\n", SumRam, SumRam/1024
        printf "    %d of %d DIMMs populated (system max capacity %s)\n",
          NumDimms, NumDimmSlots, MaxRam
      }
    '
  echo -en $heading_separator
}
      
  
OSINFO() {
  [[ $1 == / ]] && uptime_input=$(uptime) || uptime_input=$(<"$1/uptime")
  echo -e "${c_h1}OS${c_0}"
  echo -e "  ${c_h2}Distro:${c_0}   ${c_imp}$(<"$1/etc/redhat-release")${c_0}"
  echo -e "  ${c_h2}Kernel:${c_0}   ${c_imp}$(<"$1/proc/sys/kernel/osrelease")${c_0}"
  echo -e "  ${c_h2}Hostname:${c_0} $(<"$1/proc/sys/kernel/hostname")"
  awk -vH2="$c_h2" -vH0="$c_0" '
    {
      Time    = $1
      Uptime  = $3" "$4" "$5; sub(/,$/, "", Uptime)
      LoadAvg = $6" "$7" "$10" "$11" "$12
      printf "  %sSys time:%s %s\n  %sUptime:%s   %s\n  %sLoadAvg:%s  %s\n",
        H2,H0,Time, H2,H0,Uptime, H2,H0,LoadAvg
    }' <<<"$uptime_input"
  echo -en $heading_separator
}


CPUINFO() {
  cpuinfo_input=$1/proc/cpuinfo
  model_cpu=$(awk -F: '/model name/{print$2}' "$cpuinfo_input" | sort -u | sed -e "s/(R)//g" -e "s/(TM)//g" -e "s/  */ /g")
  num_cpu=$(grep processor "$cpuinfo_input" | sort -u | wc -l)
  num_cpu_phys=$(grep "physical id" "$cpuinfo_input" | sort -u | wc -l)
  [[ $num_cpu_phys -eq 0 ]] && num_cpu_phys=$num_cpu
  if [[ $num_cpu_phys -ne $num_cpu ]]; then
    num_cores_per_cpu=$(grep cores "$cpuinfo_input" | head -n1 | awk {print\$4})
    [[ -n $num_cores_per_cpu ]] && cores=", ${num_cores_per_cpu} cores/ea"
  fi
  cpu_flags=$(egrep -o "pae|lm|vmx|svm|ht|aes" "$cpuinfo_input" | sort -u | xargs echo | sed "s/ /,/g")
  echo -e "${c_h1}CPUs${c_0}"
  echo -e "  ${c_imp}${num_cpu} logical cpus${c_0} (${cpu_flags})\n  ${num_cpu_phys}${model_cpu}${cores}"
  echo -en $heading_separator
}


MEMINFO() {
  echo -e "${c_h1}MEMORY${c_0}"
  awk -vu="$mem_unit" -vH_IMP="$c_imp" -vH2="$c_h2" -vH0="$c_0" '
    
    # Grab variables from meminfo
    /^MemTotal:/        { MemTotal  = $2 }
    /^MemFree:/         { MemFree   = $2 }
    /^Buffers:/         { BuffCache += $2 }
    /^Cached:/          { BuffCache += $2 }
    /^SwapCached:/      { BuffCache += $2 }
    /^LowTotal:/        { LowTotal  = $2 }
    /^LowFree:/         { LowFree   = $2 }
    /^SwapTotal:/       { SwapTotal = $2 }
    /^SwapFree:/        { SwapFree  = $2 }
    /^Dirty:/           { Dirty     = $2 }
    /^Shmem:/           { Shmem     = $2 }
    /^Slab:/            { Slab      = $2 }
    /^PageTables:/      { PageTables      = $2 }
    /^Hugepagesize:/    { Hugepagesize    = $2 }
    /^HugePages_Total:/ { HugepagesTotal  = $2 }
    /^HugePages_Free:/  { HugepagesFree   = $2 }
    
    END {
      
      # Compute additional variables
      MemUsed         = MemTotal - MemFree
      Mem_Percent     = MemUsed * 100 / MemTotal
      MemUsedNoBC     = MemUsed - BuffCache
      MemNoBC_Percent = MemUsedNoBC * 100 / MemTotal
      Dirty_Percent   = Dirty * 100 / MemTotal
      Shmem_Percent   = Shmem * 100 / MemTotal
      Slab_Percent    = Slab * 100 / MemTotal
      PT_Percent      = PageTables * 100 / MemTotal
      HP              = Hugepagesize * HugepagesTotal
      HP_PercentRam   = HP * 100 / MemTotal
      
      # If have hugepages, calculate in-use
      if (HugepagesTotal > 0) {
        HP_Used         = (HugepagesTotal - HugepagesFree) * Hugepagesize
        HP_Used_Percent = (HugepagesTotal - HugepagesFree) * 100 / HugepagesTotal
      }
      # Else, need to avoid divide-by-zero errors
      else {
        HP_Used         = 0
        HP_Used_Percent = 0
      }
      
      # If meminfo has LowTotal (my fedora box does not)...
      if (LowTotal ~ /[0-9]+/) {
        SHOW_Lowmem=1
        LowUsed         = LowTotal - LowFree
        LowUsed_Percent = LowUsed * 100 / LowTotal
      }
      # Else, avoid divide-by-zero and hide it
      else {
        SHOW_Lowmem=0
        LowTotal        = 0
        LowUsed         = 0
        LowUsed_Percent = 0
      }
      
      # If have swap-space...
      if (SwapTotal > 0) {
        SwapUsed      = SwapTotal - SwapFree
        Swap_Percent  = SwapUsed * 100 / SwapTotal
      }
      # Else, avoid divide-by-zero errors
      else {
        SwapUsed      = 0
        Swap_Percent  = 0
      }
      
      # If meminfo has Shmem, we show it; otherwise not
      if (Shmem ~ /[0-9]+/)
        SHOW_Shmem=1
      else
        SHOW_Shmem=0
      
      # If unit is set to megabytes or gigabytes,
      # do one round of division to convert to megabytes
      if (u == "m" || u == "g") {
        MemUsed     /= 1024
        MemTotal    /= 1024
        MemUsedNoBC /= 1024
        Dirty       /= 1024
        Shmem       /= 1024
        Slab        /= 1024
        PageTables  /= 1024
        HP          /= 1024
        if (HugepagesTotal > 0) HP_Used /= 1024
        if (LowTotal > 0) { LowUsed /= 1024; LowTotal /= 1024 }
        if (SwapTotal > 0) { SwapUsed /= 1024; SwapTotal /= 1024 }
      }
      
      # If unit is set to gigabytes, do an additional division round
      # and print units with 1 decimal-point of precision
      if (u == "g") {
      
        MemUsed     /= 1024
        MemTotal    /= 1024
        MemUsedNoBC /= 1024
        Dirty       /= 1024
        Shmem       /= 1024
        Slab        /= 1024
        PageTables  /= 1024
        HP          /= 1024
        if (HugepagesTotal > 0) HP_Used /= 1024
        if (LowTotal > 0) { LowUsed /= 1024; LowTotal /= 1024 }
        if (SwapTotal > 0) { SwapUsed /= 1024; SwapTotal /= 1024 }
        
        printf    "  %sRAM:%s\n", H2, H0
        printf    "    %s%.1f%s total%s [%.1f%s (%.0f%%) used]\n", H_IMP, MemTotal, u, H0, MemUsed, u, Mem_Percent
       #printf    "    %.1f%s (%.0f%%) used\n", MemUsed, u, Mem_Percent
        printf    "    %s%.1f%s (%.0f%%) used excluding buffers/cache%s\n", H_IMP, MemUsedNoBC, u, MemNoBC_Percent, H0
        printf    "    %.2f%s (%.0f%%) dirty\n", Dirty, u, Dirty_Percent
        
        printf    "  %sHugePages:%s\n", H2, H0
        if (HugepagesTotal == 0)
          printf  "    ZERO ram pre-allocated to HugePages\n"
        else {
          printf  "    %s%.1f%s pre-allocated to HugePages (%.0f%% of total ram)%s\n", H_IMP, HP, u, HP_PercentRam, H0
          printf  "    %.1f%s of HugePages (%.0f%%) in-use by applications\n", HP_Used, u, HP_Used_Percent
        }
        
        printf    "  %sLowMem/Slab/PageTables/Shmem:%s\n", H2, H0
        if (SHOW_Lowmem == 1)
          printf  "    %.1f%s (%.0f%%) of %.1f%s LowMem in-use\n", LowUsed, u, LowUsed_Percent, LowTotal, u
        printf    "    %.2f%s (%.0f%%) of total ram used for Slab\n", Slab, u, Slab_Percent
        printf    "    %.2f%s (%.0f%%) of total ram used for PageTables\n", PageTables, u, PT_Percent
        if (SHOW_Shmem == 1)
          printf  "    %.2f%s (%.0f%%) of total ram used for Shmem\n", Shmem, u, Shmem_Percent
        
        printf    "  %sSwap:%s\n", H2, H0
        if (SwapTotal == 0)
          printf  "    %sZERO system swap space configured%s\n", H_IMP, H0
        else
          printf  "    %.1f%s (%.0f%%) used of %.1f%s total\n", SwapUsed, u, Swap_Percent, SwapTotal, u
      }
      
      # Else, if unit is megabytes or kilobytes,
      # print units with 0 decimal-points of precision,
      # print percentages with an extra decimal-point of precision
      else {
        
        printf    "  %sRAM:%s\n", H2, H0
        printf    "    %s%.0f%s total%s [%.0f%s (%.1f%%) used]\n", H_IMP, MemTotal, u, H0, MemUsed, u, Mem_Percent
       #printf    "    %.0f%s (%.1f%%) used\n", MemUsed, u, Mem_Percent
        printf    "    %s%.0f%s (%.1f%%) used excluding buffers/cache%s\n", H_IMP, MemUsedNoBC, u, MemNoBC_Percent, H0
        printf    "    %.2f%s (%.1f%%) dirty\n", Dirty, u, Dirty_Percent
        
        printf    "  %sHugePages:%s\n", H2, H0
        if (HugepagesTotal == 0)
          printf  "    ZERO ram pre-allocated to HugePages\n"
        else {
          printf  "    %s%.0f%s pre-allocated to HugePages (%.1f%% of total ram)%s\n", H_IMP, HP, u, HP_PercentRam, H0
          printf  "    %.0f%s of HugePages (%.1f%%) in-use by applications\n", HP_Used, u, HP_Used_Percent
        }
        
        printf    "  %sLowMem/Slab/PageTables/Shmem:%s\n", H2, H0
        if (SHOW_Lowmem == 1)
          printf  "    %.0f%s (%.1f%%) of %.0f%s LowMem in-use\n", LowUsed, u, LowUsed_Percent, LowTotal, u
        printf    "    %.2f%s (%.1f%%) of total ram used for Slab\n", Slab, u, Slab_Percent
        printf    "    %.2f%s (%.1f%%) of total ram used for PageTables\n", PageTables, u, PT_Percent
        if (SHOW_Shmem == 1)
          printf  "    %.2f%s (%.1f%%) of total ram used for Shmem\n", Shmem, u, Shmem_Percent
        
        printf    "  %sSwap:%s\n", H2, H0
        if (SwapTotal == 0)
          printf  "    %sZERO system swap space configured%s\n", H_IMP, H0
        else
          printf  "    %.0f%s (%.1f%%) used of %.0f%s total\n", SwapUsed, u, Swap_Percent, SwapTotal, u
      }
    }
  ' <"$1/proc/meminfo"
  echo -en $heading_separator
}


STORAGE() {
  echo -e "${c_h1}STORAGE${c_0}"
  if [[ $2 == --mpath ]]; then
    # Get multipath input from command, because $1 is system
    if [[ $1 == / && $UID -eq 0 ]]; then
      mpath_input=$(multipath -v4 -ll 2>/dev/null)
    # Get multipath input from sosreport file, if present
    elif [[ -r $1/sos_commands/devicemapper/multipath_-v4_-ll ]]; then
      mpath_input=$(<"$1/sos_commands/devicemapper/multipath_-v4_-ll")
    else
      mpath_input=
    fi
  fi 
  # If multipath --mpath option requested + returned good data, check to see if there are paths
  # If so, print out the mpath devices and hide their children from the later disk printout
  scsi_blacklist=
  if [[ -n $mpath_input ]] && ! egrep -q 'no.paths|multipath.conf.*not.exist' <<<"$mpath_input"; then
    echo -e "${c_h2}  Multipath:${c_0}"
    grep -B1 '^\[size=' <<<"$mpath_input" |
      awk '
        BEGIN { RS = "--" }
        {
          printf "    %s@%s\n", $1,
            gensub(/.*\[size=([0-9]+\.?[0-9]*) ?([[:alpha:]]{1,2})\].*/, "\\1 \\2", 1)
        }
      ' | sort | column -ts@
    scsi_blacklist=$(awk '/\\_ .* sd[[:alpha:]]+ / {printf "%s|", $3}' <<<"$mpath_input")
  fi
  # Get linux software raid (mdstat) info from where?
  if [[ $1 == / ]]; then
    mdstat_input=/proc/mdstat
  # Get mdstat input from sosreport, if present
  elif [[ -r $1/proc/mdstat ]]; then
    mdstat_input=$1/proc/mdstat
  fi
  # Get raid_components
  raid_components=$(grep ^md "$mdstat_input" 2>/dev/null | cut -d\  -f5- | egrep -o '[[:alpha:]]+' | sort -u | awk '{printf "%s|", $1}')
  # Append software raid component disks to the blacklist
  scsi_blacklist=$scsi_blacklist$raid_components
# FIXME:
#  scsi_blacklist=$scsi_blacklist$(awk '
#    /^md./ {
#      printf gensub(/.* ([[:alpha:]]+)[0-9]*\[[0-9]+\] .*/, "\\1|", "g")
#    }' <"$mdstat_input")

  # Yay, let's go.
  [[ -n $scsi_blacklist ]] && bl=y || { bl=n; scsi_blacklist=NULL; }
  echo -e "${c_h2}  Disks:${c_0}"
  egrep -v "${scsi_blacklist%?}" "$1/proc/partitions" |
    awk -vblacklisted=$bl '
      $4 ~ /^hd.$|^sd[[:alpha:]]{1,2}$|^md.$|^r+om.$|^r?flash.$|^rd\/c.{1,2}d.{1,2}$|^ida\/c.d.$|^i2o\/hd[[:alpha:]]+$|^amiraid\/ar.{1,2}$|cbd\/.$|^cciss\/c.d.{1,2}$|^iseries\/vd[[:alpha:]]{1,2}$|^ataraid\/d.{1,2}$|^emd\/.{1,2}$|^carmel\/.{1,2}$|^mmcblk.$|^ub.$|^xvd.$|^vd.$/ {
        numdisks ++
        disksize =  $3/1024/1024
        sum_gb   += disksize
        disk[$4] =  disksize
      }
      END {
        if (blacklisted == "y")
          print  "    (Multipath and/or software raid components hidden)"
        printf   "    %d disks, totaling %.0f GiB (%.2f TiB)\n", numdisks, sum_gb, sum_gb/1024
        n = asorti(disk, disk_sorted)
        for (i = 1; i <= n; i++)
          printf "    %s   %.1f G\n", disk_sorted[i], disk[disk_sorted[i]]
      }
    '
  echo -en $heading_separator
}


LSPCI() {
  [[ -z $1 ]] && lspci_input=$(lspci) || lspci_input=$(<"$1/lspci")
  echo -e "${c_h1}LSPCI${c_0}"
  awk -vH_IMP="$c_imp" -vH2="$c_h2" -vH0="$c_0" '
    $2 !~ /^Eth|^Net/ {
      next
    }
    {
      split($1, slot, ":")
      $1 = ""
      sub(" ", "")
      split($0, type, ":")
      iface[type[2]] ++
      if (!(slot[1] SUBSEP type[2] in slots)) {
        slots[slot[1], type[2]]
        slotcount[type[2]] ++
      }
    }
    END {
      printf "%s  Netdevs:%s\n", H2, H0
      for (ifacetype in iface) {
        slotc = slotcount[ifacetype]
        typec = iface[ifacetype]
        ports = ""
        if (typec > 1)
          ports = H_IMP" {" slotc "," typec/slotc "-port}"H0
        printf "    %s%s%s\n", typec, ifacetype, ports
      }
    }
  ' <<<"$lspci_input"
  echo -e "${c_h2}  Graphics:${c_0}"
  awk -F: '$2 ~ /^.... VGA/ { print "   "$3}' <<<"$lspci_input"
  echo -en $heading_separator
}


ETHTOOL() {
  # If running on local system, grab interfaces from /sys, and
  # prepare to use ethtool command
  if [[ -z $1 ]]; then
    ethdevs=$(ls /sys/class/net | egrep -v 'lo|sit0')
    __ethtool()   { ethtool $1; }
    __ethtool_i() { ethtool -i $1; }
  # If running on sosreport-root, grab interfaces from ethtool_iface files, and
  # prepare to pull ethtool info from same files
  elif ls "$1"/sos_commands/networking/ethtool* &>/dev/null; then
    cd "$1"/sos_commands/networking
    ethdevs=$(ls ethtool_[[:alpha:]]* | cut -d_ -f2)
    __ethtool()   { cat ethtool_$1; }
    __ethtool_i() { [[ -r ethtool_-i_$1 ]] && cat ethtool_-i_$1; }
  # Otherwise, set ethdevs to null
  else
    ethdevs=
  fi
  
  # If have ethdevs to work on ...
  if [[ -n $ethdevs ]]; then
    echo -e "${c_h1}ETHTOOL${c_0}"
    for i in $ethdevs; do
      echo -e "  $i~$(__ethtool $i |
      awk '
        /Link detected:/    { link = $3; sub(/yes/, "UP", link); sub(/no/, "DOWN", link) }
        /Speed:/            { spd = $2 }
        /Duplex:/           { dup = tolower($2) }
        /Auto-negotiation:/ { aneg = $2; sub(/on/, "Y", aneg); sub(/off/, "N", aneg) }
        END {
          if (link == "UP" && spd != "")
            linkdetails = " "spd" "dup" (autoneg="aneg")"
          printf "link=%s%s~", link, linkdetails
        }
      '
      )$(__ethtool_i $i |
      awk '
        BEGIN { driver="UNKNOWN"; drv_vers=""; fw_vers="" }
        /^driver:/           { if ($2 != "") driver=$2 }
        /^version:/          { if ($2 != "") drv_vers=" v"$2 }
        /^firmware-version:/ { if ($2 != "") fw_vers=" / fw "$2 }
        END { printf "drv %s%s%s\n", driver, drv_vers, fw_vers }
      '
    )"
    done | column -ts~ |
      awk -vH0="$c_0" -vU="$c_up" -vD="$c_down" '/DOWN/{print D $0 H0}  /UP/{print U $0 H0}'
    [[ ${PWD##*/} == networking ]] && cd - &>/dev/null
  fi
  echo -en $heading_separator
}


PROC_NET() {
  echo -e "${c_h1}PROC/NET/DEV${c_0}"
  tail -n+3 "$1/proc/net/dev" | egrep -v 'lo:|sit0:' | sed 's,:, ,' |
    awk '
      {
        Iface[$1]     = $1
        RxMBytes[$1]  = $2 / 1024 / 1024
        RxPackets[$1] = $3
        RxErrs[$1]    = $4
        RxDrop[$1]    = $5
        TxMBytes[$1]  = $10 / 1024 / 1024
        TxPackets[$1] = $11
        TxErrs[$1]    = $12
        TxDrop[$1]    = $13
      }
      END {
        print "  Iface~RxMBytes~RxPackets~RxErrs~RxDrop~TxMBytes~TxPackets~TxErrs~TxDrop"
        n = asorti(Iface, IF)
        for (i = 1; i <= n; i++)
          printf "  %s~%0.f~%d~%d~%d~%0.f~%d~%d~%d\n",
            IF[i], RxMBytes[IF[i]], RxPackets[IF[i]], RxErrs[IF[i]], RxDrop[IF[i]],
            TxMBytes[IF[i]], TxPackets[IF[i]], TxErrs[IF[i]], TxDrop[IF[i]]
      }
    ' | column -ts~ |
      awk -vH0="$c_0" -vH2="$c_h2" -vH3="$c_h3" '
        {
          if (NR == 1) print H2 $0 H0
          else printf gensub(/(^  [[:graph:]]+ )/,   H3"\\1"H0, 1)"\n"
        }'
        
  echo -e "${c_h1}PROC/NET/SOCKSTAT${c_0}"
  awk -vS="  " -vH3="$c_h3" -vH0="$c_0" '
    { printf gensub(/^(.*:)/, S H3"\\1"H0, 1)"\n" }' <"$1/proc/net/sockstat"
  echo -en $heading_separator
}


TAINTCHECK() {
  tainted=$(<"$1/proc/sys/kernel/tainted")
  if [[ $tainted -eq 0 ]]; then
    echo "0 (kernel untainted)"
    return
  else
    taintvals=$(
      for taint in 536870912 268435456 4096 2048 1024 512 256 128 64 32 16 8 4 2 1; do
        if [[ $tainted -gt $taint ]]; then
          printf "$taint "
          tainted=$((tainted-taint))
        elif [[ $tainted -eq $taint ]]; then
          printf "$taint "                                                                                     
          break
        fi
      done
    )
  fi
  # See /usr/share/doc/kernel-doc*/Documentation/sysctl/kernel.txt
  # Or linux/kernel/panic.c
  t[1]="Proprietary module has been loaded"
  t[2]="Module has been forcibly loaded"
  t[4]="SMP with CPUs not designed for SMP"
  t[8]="User forced a module unload"
  t[16]="System experienced a machine check exception"
  t[32]="System has hit bad_page"
  t[64]="Userspace-defined naughtiness"
  t[128]="Kernel has oopsed before"
  t[256]="ACPI table overridden"
  t[512]="Taint on warning"
  t[1024]="Modules from drivers/staging are loaded"
  t[2048]="Working around severe firmware bug"
  t[4096]="Out-of-tree module has been loaded"
  t[268435456]="Hardware is unsupported"
  t[536870912]="Technology Preview code is loaded"
  echo "$taintvals"
  for n in $taintvals; do
    echo "$H3INDENT${t[$n]}"
  done
}


PROC_STAT() {
  btime=$(date --date=@$(awk '/btime/{print $2}' <"$1/proc/stat"))
  awk -vS="$H2INDENT" -vBTIME="$btime" -vH3="$c_h3" -vH0="$c_0" '
    BEGIN {
      printf "%s%sb[oot]time:%s %s\n", S, H3, H0, BTIME
    }
    /^cpu / {
      TotalTime = $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9 + $10 + $11
      user    = $2 * 100 / TotalTime
      nice    = $3 * 100 / TotalTime
      sys     = $4 * 100 / TotalTime
      idle    = $5 * 100 / TotalTime
      iowait  = $6 * 100 / TotalTime
      irq     = $7 * 100 / TotalTime
      softirq = $8 * 100 / TotalTime
      steal   = $9 * 100 / TotalTime
     #guest      = $10
     #guest_nice = $11 
      printf "%s%scpu [time distribution since last boot]:%s\n%s  us %0.f%%, ni %0.f%%, sys %0.f%%, idle %0.f%%, iowait %0.f%%, irq %0.f%%, sftirq %0.f%%, steal %0.f%%\n",
      S, H3, H0, S, user, nice, sys, idle, iowait, irq, softirq, steal
    }
    /procs_running/ {
      printf "%s%sprocs_running:%s %d\n", S, H3, H0, $2
    }
    /procs_blocked/ {
      printf "%s%sprocs_blocked:%s %d\n", S, H3, H0, $2
    }
  ' <"$1/proc/stat"
}




KERN() {
echo -e "${c_h1}PROC/${c_0}
  ${c_h2}stat${c_0}\n$(PROC_STAT "$1")
  ${c_h2}cmdline${c_0}
    $(<"$1/proc/cmdline")"
  echo -en $heading_separator
}


SYSCTL() {
  # VM PageSize (don't know how to find this from a sosreport,
  # but I doubt that will often be a problem)
  [[ $1 == / ]] && pgsz=$(getconf PAGESIZE) || pgsz=4
  echo -e "${c_h1}SYSCTLS${c_0}
  ${c_h2}kernel.${c_0}
    ${c_h3}osrelease:${c_0} $(<"$1/proc/sys/kernel/osrelease")
    ${c_h3}tainted:${c_0} $(TAINTCHECK "$1")
    ${c_h3}random.boot_id:${c_0} $(<"$1/proc/sys/kernel/random/boot_id")
    ${c_h3}random.entropy_avail:${c_0} $(<"$1/proc/sys/kernel/random/entropy_avail")
    ${c_h3}panic (seconds til reboot):${c_0} $(<"$1/proc/sys/kernel/panic")
    ${c_h3}hung_task_panic:${c_0} $(<"$1/proc/sys/kernel/hung_task_panic")
    ${c_h3}panic_on_oops:${c_0} $(<"$1/proc/sys/kernel/panic_on_oops")
    ${c_h3}panic_on_unrecovered_nmi:${c_0} $(<"$1/proc/sys/kernel/panic_on_unrecovered_nmi")
    ${c_h3}sysrq:${c_0} $(<"$1/proc/sys/kernel/sysrq")
    ${c_h3}sem:${c_0} $(awk -vS="$H3INDENT" '{print $1,$2,$3,$4; printf "%smax semaphores per array = %d\n%smax sems system-wide     = %d\n%smax ops per semop call   = %d\n%smax number of arrays     = %d\n", S,$1,S,$2,S,$3,S,$4}' <"$1/proc/sys/kernel/sem")
    ${c_h3}shmall (pages):${c_0} $(<"$1/proc/sys/kernel/shmall") ($(awk -vPGSZ="$pgsz" '{printf "%.1f G max total shared memory\n", $1*PGSZ/1024/1024}' <"$1/proc/sys/kernel/shmall"))
    ${c_h3}shmmax (bytes):${c_0} $(<"$1/proc/sys/kernel/shmmax") ($(awk '{printf "%.2f G max segment size\n", $1/1024/1024/1024}' <"$1/proc/sys/kernel/shmmax"))
    ${c_h3}shmmni (segments):${c_0} $(<"$1/proc/sys/kernel/shmmni") (max number of segs)
  ${c_h2}vm.${c_0}
    ${c_h3}nr_hugepages:${c_0} $(<"$1/proc/sys/vm/nr_hugepages")
    ${c_h3}overcommit_{memory,ratio}:${c_0} $(<"$1/proc/sys/vm/overcommit_memory") / $(<"$1/proc/sys/vm/overcommit_ratio")
    ${c_h3}panic_on_oom:${c_0} $(<"$1/proc/sys/vm/panic_on_oom")
  ${c_h2}net.${c_0}
    ${c_h3}ipv4.icmp_echo_ignore_all:${c_0} $(<"$1/proc/sys/net/ipv4/icmp_echo_ignore_all")
    ${c_h3}ipv4.ip_forward:${c_0} $(<"$1/proc/sys/net/ipv4/ip_forward")
    ${c_h3}ipv4.tcp_max_orphans (sockets):${c_0} $(<"$1/proc/sys/net/ipv4/tcp_max_orphans") ($(awk '{printf "%d M @ max 64 K per orphan\n", $1*64/1024}' <"$1/proc/sys/net/ipv4/tcp_max_orphans"))
    ${c_h3}ipv4.tcp_mem (pages):${c_0} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_mem") ($(awk -vPGSZ="$pgsz" '{printf "%.2f G, %.2f G, %.2f G\n", $1*PGSZ/1024/1024,$2*PGSZ/1024/1024,$3*PGSZ/1024/1024}' <"$1/proc/sys/net/ipv4/tcp_mem"))
    ${c_h3}ipv4.udp_mem (pages):${c_0} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/udp_mem") ($(awk -vPGSZ="$pgsz" '{printf "%.2f G, %.2f G, %.2f G\n", $1*PGSZ/1024/1024,$2*PGSZ/1024/1024,$3*PGSZ/1024/1024}' <"$1/proc/sys/net/ipv4/udp_mem"))
    ${c_h3}ipv4.tcp_rmem (bytes):${c_0} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_rmem") ($(awk '{printf "%d K, %d K, %d K\n", $1/1024,$2/1024,$3/1024}' <"$1/proc/sys/net/ipv4/tcp_rmem"))
    ${c_h3}ipv4.tcp_wmem (bytes):${c_0} $(awk '{print $1,$2,$3}' <"$1/proc/sys/net/ipv4/tcp_wmem") ($(awk '{printf "%d K, %d K, %d K\n", $1/1024,$2/1024,$3/1024}' <"$1/proc/sys/net/ipv4/tcp_wmem"))
    ${c_h3}ipv4.udp_rmem_min (bytes):${c_0} $(<"$1/proc/sys/net/ipv4/udp_rmem_min") ($(awk '{printf "%d K\n", $1/1024}' <"$1/proc/sys/net/ipv4/udp_rmem_min"))
    ${c_h3}ipv4.udp_wmem_min (bytes):${c_0} $(<"$1/proc/sys/net/ipv4/udp_wmem_min") ($(awk '{printf "%d K\n", $1/1024}' <"$1/proc/sys/net/ipv4/udp_wmem_min"))"
  echo -en $heading_separator
}


#-------------------------------------------------------------------------------
# BLEH
# Eventually I'll probably replace all of this with a python loader.
# Python's argparse is so much better than dealing with all this crap.

# If no SOSREPORT-ROOT provided, run checks against local system
if [[ -z $sosroot ]]; then

  [[ $UID -eq 0 && -n $bios ]] &&     DMIDECODE
  [[ -n $os ]] &&                     OSINFO /
  [[ -n $cpu ]] &&                    CPUINFO /
  [[ -n $mem ]] &&                    MEMINFO /
  if [[ -n $mpath ]]; then            STORAGE / --mpath
  elif [[ -n $disks ]]; then          STORAGE /
  fi
  [[ -n $lspci ]] &&                  LSPCI
  [[ $UID -eq 0 && -n $ethtool ]] &&  ETHTOOL
  [[ -n $net ]] &&                    PROC_NET /
  [[ -n $kern ]] &&                   KERN /
  [[ -n $sysctl ]] &&                 SYSCTL /
  
# If SOSREPORT-ROOT provided, use that
else

  if [[ -n $bios ]]; then
    if [[ -r $sosroot/dmidecode ]]; then
      DMIDECODE "$sosroot/dmidecode"
    elif [[ -r $sosroot/sos_commands/kernel.dmidecode ]]; then
      DMIDECODE "$sosroot/sos_commands/kernel.dmidecode"
    fi
  fi
  [[ -n $os && -d $sosroot/proc/sys ]] &&                   OSINFO "$sosroot"
  [[ -n $cpu   && -r $sosroot/proc/cpuinfo ]] &&            CPUINFO "$sosroot"
  [[ -n $mem   && -r $sosroot/proc/meminfo ]] &&            MEMINFO "$sosroot"
  if [[ -n $mpath && -r $sosroot/proc/partitions ]]; then   STORAGE "$sosroot" --mpath
  elif [[ -n $disks && -r $sosroot/proc/partitions ]]; then STORAGE "$sosroot"
  fi
  [[ -n $lspci && -r $sosroot/lspci ]] &&                   LSPCI "$sosroot"
  [[ -n $ethtool ]] &&                                      ETHTOOL "$sosroot"
  [[ -n $net && -d $sosroot/proc/net ]] &&                  PROC_NET "$sosroot"
  [[ -n $kern && -d $sosroot/proc ]] &&                     KERN "$sosroot"
  [[ -n $sysctl && -d $sosroot/proc/sys ]] &&               SYSCTL "$sosroot"
fi


